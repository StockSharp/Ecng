<#@ template language="C#" #>
<# 
var tTypes = new System.Collections.Generic.List<string> {"Decimal", "Double", "Single", "Int32", "UInt32", "Int64", "UInt64", "Int16", "UInt16", "Byte", "SByte", "DateTime", "TimeSpan"};
 #>
// *************************************************************************************
// ULTRACHART™ © Copyright ulc software Services Ltd. 2011-2014. All rights reserved.
//  
// Web: http://www.ultrachart.com
// Support: support@ultrachart.com
// 
// DataDistributionCalculators.cs is part of Ultrachart, a High Performance WPF & Silverlight Chart. 
// For full terms and conditions of the license, see http://www.ultrachart.com/ultrachart-eula/
// 
// This source code is protected by international copyright law. Unauthorized
// reproduction, reverse-engineering, or distribution of all or any portion of
// this source code is strictly prohibited.
// 
// This source code contains confidential and proprietary trade secrets of
// ulc software Services Ltd., and should at no time be copied, transferred, sold,
// distributed or made available without express written permission.
// *************************************************************************************
using System;
using System.Linq;
using System.Collections.Generic;
using Ecng.Xaml.Charting.Common.Extensions;
using Ecng.Xaml.Charting.Numerics.GenericMath;
// ReSharper Disable All

namespace Ecng.Xaml.Charting.Model.DataSeries
{	
<# 
foreach (string tType in tTypes)
{ 	
#>	
	#region AutoGenerated <#= tType #>DataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class List<#= tType #>DataDistributionCalculator : BaseDataDistributionCalculator<<#= tType #>>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public List<#= tType #>DataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<<#= tType #>> xValues, <#= tType #> newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<<#= tType #>> xValues, int countBeforeAppending, IEnumerable<<#= tType #>> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<<#= tType #>> xValues, int indexWhereInserted, <#= tType #> newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<<#= tType #>> xValues, int indexWhereInserted, int insertedCount, IEnumerable<<#= tType #>> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<<#= tType #>> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<<#= tType #>> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(<#= tType #> xValue) {<#if(tType == "DateTime" || tType == "TimeSpan"){#> return xValue.Ticks;<#}else{#> return (double)xValue;<#}#> }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class <#= tType #>DataDistributionCalculator : BaseDataDistributionCalculator<<#= tType #>>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<<#= tType #>> xValues, <#= tType #> newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<<#= tType #>>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<<#= tType #>> xValues, int countBeforeAppending, IEnumerable<<#= tType #>> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as <#= tType #>[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<<#= tType #>>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (<#= tType #> item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<<#= tType #>> xValues2, int indexWhereInserted, <#= tType #> newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<<#= tType #>>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<<#= tType #>> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<<#= tType #>> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<<#= tType #>>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<<#= tType #>> xValues, <#= tType #> newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<<#= tType #>> xValues, int countBeforeAppending, <#= tType #>[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(<#= tType #> xValue) {<#if(tType == "DateTime" || tType == "TimeSpan"){#> return xValue.Ticks;<#}else{#> return (double)xValue;<#}#> }
	}

	#endregion	
<# 
}	
#>
}

// ReSharper Restore All