// *************************************************************************************
// ULTRACHART™ © Copyright ulc software Services Ltd. 2011-2014. All rights reserved.
//  
// Web: http://www.ultrachart.com
// Support: support@ultrachart.com
// 
// DataDistributionCalculators.cs is part of Ultrachart, a High Performance WPF & Silverlight Chart. 
// For full terms and conditions of the license, see http://www.ultrachart.com/ultrachart-eula/
// 
// This source code is protected by international copyright law. Unauthorized
// reproduction, reverse-engineering, or distribution of all or any portion of
// this source code is strictly prohibited.
// 
// This source code contains confidential and proprietary trade secrets of
// ulc software Services Ltd., and should at no time be copied, transferred, sold,
// distributed or made available without express written permission.
// *************************************************************************************
using System;
using System.Linq;
using System.Collections.Generic;
using Ecng.Xaml.Charting.Common.Extensions;
using Ecng.Xaml.Charting.Numerics.GenericMath;
// ReSharper Disable All

namespace Ecng.Xaml.Charting.Model.DataSeries
{	
	
	#region AutoGenerated DecimalDataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListDecimalDataDistributionCalculator : BaseDataDistributionCalculator<Decimal>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListDecimalDataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<Decimal> xValues, Decimal newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<Decimal> xValues, int countBeforeAppending, IEnumerable<Decimal> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<Decimal> xValues, int indexWhereInserted, Decimal newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<Decimal> xValues, int indexWhereInserted, int insertedCount, IEnumerable<Decimal> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<Decimal> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<Decimal> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(Decimal xValue) { return (double)xValue; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class DecimalDataDistributionCalculator : BaseDataDistributionCalculator<Decimal>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<Decimal> xValues, Decimal newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<Decimal>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<Decimal> xValues, int countBeforeAppending, IEnumerable<Decimal> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as Decimal[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<Decimal>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (Decimal item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<Decimal> xValues2, int indexWhereInserted, Decimal newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<Decimal>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<Decimal> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<Decimal> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<Decimal>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<Decimal> xValues, Decimal newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<Decimal> xValues, int countBeforeAppending, Decimal[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(Decimal xValue) { return (double)xValue; }
	}

	#endregion	
	
	#region AutoGenerated DoubleDataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListDoubleDataDistributionCalculator : BaseDataDistributionCalculator<Double>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListDoubleDataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<Double> xValues, Double newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<Double> xValues, int countBeforeAppending, IEnumerable<Double> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<Double> xValues, int indexWhereInserted, Double newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<Double> xValues, int indexWhereInserted, int insertedCount, IEnumerable<Double> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<Double> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<Double> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(Double xValue) { return (double)xValue; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class DoubleDataDistributionCalculator : BaseDataDistributionCalculator<Double>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<Double> xValues, Double newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<Double>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<Double> xValues, int countBeforeAppending, IEnumerable<Double> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as Double[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<Double>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (Double item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<Double> xValues2, int indexWhereInserted, Double newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<Double>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<Double> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<Double> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<Double>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<Double> xValues, Double newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<Double> xValues, int countBeforeAppending, Double[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(Double xValue) { return (double)xValue; }
	}

	#endregion	
	
	#region AutoGenerated SingleDataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListSingleDataDistributionCalculator : BaseDataDistributionCalculator<Single>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListSingleDataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<Single> xValues, Single newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<Single> xValues, int countBeforeAppending, IEnumerable<Single> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<Single> xValues, int indexWhereInserted, Single newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<Single> xValues, int indexWhereInserted, int insertedCount, IEnumerable<Single> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<Single> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<Single> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(Single xValue) { return (double)xValue; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class SingleDataDistributionCalculator : BaseDataDistributionCalculator<Single>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<Single> xValues, Single newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<Single>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<Single> xValues, int countBeforeAppending, IEnumerable<Single> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as Single[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<Single>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (Single item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<Single> xValues2, int indexWhereInserted, Single newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<Single>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<Single> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<Single> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<Single>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<Single> xValues, Single newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<Single> xValues, int countBeforeAppending, Single[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(Single xValue) { return (double)xValue; }
	}

	#endregion	
	
	#region AutoGenerated Int32DataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListInt32DataDistributionCalculator : BaseDataDistributionCalculator<Int32>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListInt32DataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<Int32> xValues, Int32 newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<Int32> xValues, int countBeforeAppending, IEnumerable<Int32> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<Int32> xValues, int indexWhereInserted, Int32 newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<Int32> xValues, int indexWhereInserted, int insertedCount, IEnumerable<Int32> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<Int32> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<Int32> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(Int32 xValue) { return (double)xValue; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class Int32DataDistributionCalculator : BaseDataDistributionCalculator<Int32>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<Int32> xValues, Int32 newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<Int32>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<Int32> xValues, int countBeforeAppending, IEnumerable<Int32> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as Int32[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<Int32>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (Int32 item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<Int32> xValues2, int indexWhereInserted, Int32 newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<Int32>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<Int32> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<Int32> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<Int32>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<Int32> xValues, Int32 newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<Int32> xValues, int countBeforeAppending, Int32[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(Int32 xValue) { return (double)xValue; }
	}

	#endregion	
	
	#region AutoGenerated UInt32DataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListUInt32DataDistributionCalculator : BaseDataDistributionCalculator<UInt32>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListUInt32DataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<UInt32> xValues, UInt32 newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<UInt32> xValues, int countBeforeAppending, IEnumerable<UInt32> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<UInt32> xValues, int indexWhereInserted, UInt32 newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<UInt32> xValues, int indexWhereInserted, int insertedCount, IEnumerable<UInt32> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<UInt32> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<UInt32> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(UInt32 xValue) { return (double)xValue; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class UInt32DataDistributionCalculator : BaseDataDistributionCalculator<UInt32>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<UInt32> xValues, UInt32 newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<UInt32>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<UInt32> xValues, int countBeforeAppending, IEnumerable<UInt32> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as UInt32[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<UInt32>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (UInt32 item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<UInt32> xValues2, int indexWhereInserted, UInt32 newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<UInt32>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<UInt32> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<UInt32> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<UInt32>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<UInt32> xValues, UInt32 newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<UInt32> xValues, int countBeforeAppending, UInt32[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(UInt32 xValue) { return (double)xValue; }
	}

	#endregion	
	
	#region AutoGenerated Int64DataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListInt64DataDistributionCalculator : BaseDataDistributionCalculator<Int64>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListInt64DataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<Int64> xValues, Int64 newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<Int64> xValues, int countBeforeAppending, IEnumerable<Int64> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<Int64> xValues, int indexWhereInserted, Int64 newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<Int64> xValues, int indexWhereInserted, int insertedCount, IEnumerable<Int64> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<Int64> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<Int64> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(Int64 xValue) { return (double)xValue; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class Int64DataDistributionCalculator : BaseDataDistributionCalculator<Int64>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<Int64> xValues, Int64 newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<Int64>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<Int64> xValues, int countBeforeAppending, IEnumerable<Int64> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as Int64[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<Int64>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (Int64 item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<Int64> xValues2, int indexWhereInserted, Int64 newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<Int64>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<Int64> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<Int64> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<Int64>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<Int64> xValues, Int64 newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<Int64> xValues, int countBeforeAppending, Int64[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(Int64 xValue) { return (double)xValue; }
	}

	#endregion	
	
	#region AutoGenerated UInt64DataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListUInt64DataDistributionCalculator : BaseDataDistributionCalculator<UInt64>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListUInt64DataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<UInt64> xValues, UInt64 newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<UInt64> xValues, int countBeforeAppending, IEnumerable<UInt64> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<UInt64> xValues, int indexWhereInserted, UInt64 newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<UInt64> xValues, int indexWhereInserted, int insertedCount, IEnumerable<UInt64> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<UInt64> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<UInt64> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(UInt64 xValue) { return (double)xValue; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class UInt64DataDistributionCalculator : BaseDataDistributionCalculator<UInt64>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<UInt64> xValues, UInt64 newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<UInt64>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<UInt64> xValues, int countBeforeAppending, IEnumerable<UInt64> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as UInt64[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<UInt64>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (UInt64 item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<UInt64> xValues2, int indexWhereInserted, UInt64 newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<UInt64>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<UInt64> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<UInt64> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<UInt64>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<UInt64> xValues, UInt64 newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<UInt64> xValues, int countBeforeAppending, UInt64[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(UInt64 xValue) { return (double)xValue; }
	}

	#endregion	
	
	#region AutoGenerated Int16DataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListInt16DataDistributionCalculator : BaseDataDistributionCalculator<Int16>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListInt16DataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<Int16> xValues, Int16 newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<Int16> xValues, int countBeforeAppending, IEnumerable<Int16> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<Int16> xValues, int indexWhereInserted, Int16 newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<Int16> xValues, int indexWhereInserted, int insertedCount, IEnumerable<Int16> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<Int16> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<Int16> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(Int16 xValue) { return (double)xValue; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class Int16DataDistributionCalculator : BaseDataDistributionCalculator<Int16>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<Int16> xValues, Int16 newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<Int16>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<Int16> xValues, int countBeforeAppending, IEnumerable<Int16> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as Int16[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<Int16>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (Int16 item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<Int16> xValues2, int indexWhereInserted, Int16 newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<Int16>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<Int16> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<Int16> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<Int16>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<Int16> xValues, Int16 newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<Int16> xValues, int countBeforeAppending, Int16[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(Int16 xValue) { return (double)xValue; }
	}

	#endregion	
	
	#region AutoGenerated UInt16DataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListUInt16DataDistributionCalculator : BaseDataDistributionCalculator<UInt16>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListUInt16DataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<UInt16> xValues, UInt16 newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<UInt16> xValues, int countBeforeAppending, IEnumerable<UInt16> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<UInt16> xValues, int indexWhereInserted, UInt16 newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<UInt16> xValues, int indexWhereInserted, int insertedCount, IEnumerable<UInt16> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<UInt16> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<UInt16> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(UInt16 xValue) { return (double)xValue; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class UInt16DataDistributionCalculator : BaseDataDistributionCalculator<UInt16>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<UInt16> xValues, UInt16 newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<UInt16>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<UInt16> xValues, int countBeforeAppending, IEnumerable<UInt16> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as UInt16[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<UInt16>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (UInt16 item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<UInt16> xValues2, int indexWhereInserted, UInt16 newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<UInt16>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<UInt16> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<UInt16> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<UInt16>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<UInt16> xValues, UInt16 newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<UInt16> xValues, int countBeforeAppending, UInt16[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(UInt16 xValue) { return (double)xValue; }
	}

	#endregion	
	
	#region AutoGenerated ByteDataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListByteDataDistributionCalculator : BaseDataDistributionCalculator<Byte>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListByteDataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<Byte> xValues, Byte newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<Byte> xValues, int countBeforeAppending, IEnumerable<Byte> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<Byte> xValues, int indexWhereInserted, Byte newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<Byte> xValues, int indexWhereInserted, int insertedCount, IEnumerable<Byte> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<Byte> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<Byte> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(Byte xValue) { return (double)xValue; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class ByteDataDistributionCalculator : BaseDataDistributionCalculator<Byte>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<Byte> xValues, Byte newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<Byte>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<Byte> xValues, int countBeforeAppending, IEnumerable<Byte> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as Byte[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<Byte>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (Byte item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<Byte> xValues2, int indexWhereInserted, Byte newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<Byte>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<Byte> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<Byte> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<Byte>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<Byte> xValues, Byte newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<Byte> xValues, int countBeforeAppending, Byte[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(Byte xValue) { return (double)xValue; }
	}

	#endregion	
	
	#region AutoGenerated SByteDataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListSByteDataDistributionCalculator : BaseDataDistributionCalculator<SByte>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListSByteDataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<SByte> xValues, SByte newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<SByte> xValues, int countBeforeAppending, IEnumerable<SByte> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<SByte> xValues, int indexWhereInserted, SByte newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<SByte> xValues, int indexWhereInserted, int insertedCount, IEnumerable<SByte> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<SByte> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<SByte> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(SByte xValue) { return (double)xValue; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class SByteDataDistributionCalculator : BaseDataDistributionCalculator<SByte>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<SByte> xValues, SByte newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<SByte>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<SByte> xValues, int countBeforeAppending, IEnumerable<SByte> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as SByte[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<SByte>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (SByte item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<SByte> xValues2, int indexWhereInserted, SByte newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<SByte>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<SByte> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<SByte> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<SByte>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<SByte> xValues, SByte newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<SByte> xValues, int countBeforeAppending, SByte[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(SByte xValue) { return (double)xValue; }
	}

	#endregion	
	
	#region AutoGenerated DateTimeDataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListDateTimeDataDistributionCalculator : BaseDataDistributionCalculator<DateTime>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListDateTimeDataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<DateTime> xValues, DateTime newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<DateTime> xValues, int countBeforeAppending, IEnumerable<DateTime> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<DateTime> xValues, int indexWhereInserted, DateTime newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<DateTime> xValues, int indexWhereInserted, int insertedCount, IEnumerable<DateTime> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<DateTime> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<DateTime> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(DateTime xValue) { return xValue.Ticks; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class DateTimeDataDistributionCalculator : BaseDataDistributionCalculator<DateTime>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<DateTime> xValues, DateTime newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<DateTime>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<DateTime> xValues, int countBeforeAppending, IEnumerable<DateTime> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as DateTime[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<DateTime>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (DateTime item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<DateTime> xValues2, int indexWhereInserted, DateTime newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<DateTime>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<DateTime> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<DateTime> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<DateTime>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<DateTime> xValues, DateTime newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<DateTime> xValues, int countBeforeAppending, DateTime[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(DateTime xValue) { return xValue.Ticks; }
	}

	#endregion	
	
	#region AutoGenerated TimeSpanDataDistributionCalculator

	/// <summary>
	/// A specialised type of DataDistributionCalculator which can only be used on List<T> (never FIFO buffers)
	/// </summary>
	internal sealed class ListTimeSpanDataDistributionCalculator : BaseDataDistributionCalculator<TimeSpan>
    {
        const double e = 1.0 / 8000.0;
        private double _currentSpacing = 1.0;

        public ListTimeSpanDataDistributionCalculator()
        {
            IsSortedAscending = true;
            IsEvenlySpaced = true;
        }

        /// <summary>
        /// Gets or sets if the data is sorted
        /// </summary>
        public bool IsSortedAscending
        {
            get { return base.DataIsSortedAscending; }
            set { base.DataIsSortedAscending = value; }
        }

        /// <summary>
        /// Gets or sets if the data is evenly spaced, within a visual epsilon (typically 1.0/8000.0 of the default spacing)
        /// </summary>
        public bool IsEvenlySpaced
        {
            get { return base.DataIsEvenlySpaced; }
            set { base.DataIsEvenlySpaced = value; }
        }

        internal double CurrentSpacing { get { return _currentSpacing; } }

        public override void OnAppendXValue(ISeriesColumn<TimeSpan> xValues, TimeSpan newXValue, bool acceptsUnsortedData)
        {
            OnAppend(xValues, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnAppendXValues(ISeriesColumn<TimeSpan> xValues, int countBeforeAppending, IEnumerable<TimeSpan> newXValues, bool acceptsUnsortedData)
        {
            OnAppend(xValues, ((ISeriesColumn)xValues).Count - countBeforeAppending);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValue(ISeriesColumn<TimeSpan> xValues, int indexWhereInserted, TimeSpan newXValue, bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, 1);

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public override void OnInsertXValues(ISeriesColumn<TimeSpan> xValues, int indexWhereInserted, int insertedCount, IEnumerable<TimeSpan> newXValues,
            bool acceptsUnsortedData)
        {
            OnInsert(xValues, indexWhereInserted, newXValues.Count());

            if (!acceptsUnsortedData && !IsSortedAscending)
                throw new InvalidOperationException(DataAppendedUnsortedWarning);
        }

        public void OnAppend(IList<TimeSpan> valuesAfterAppend, int appendedCount)
        {
            // Sorted calculation. If not sorted, don't bother updating flags
            if (!IsSortedAscending) return;

            // Check new section sorted. IsSorted |= newSectionSorted
            int totalCount = valuesAfterAppend.Count;
            int endIndex = totalCount - 1;
            int startIndex = totalCount - appendedCount;
            bool newSectionSortedAscending = appendedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterAppend, startIndex, appendedCount);
            bool newSectionAfterOldSection = (totalCount <= 1 || startIndex <= 0 || valuesAfterAppend[startIndex] >= valuesAfterAppend[startIndex - 1]);
            IsSortedAscending = newSectionSortedAscending && newSectionAfterOldSection;

            // Evenly Spaced calculation. If not evenly spaced, don't bother updating flags
            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section Evenly Spaced
            bool newSectionEvenlySpaced = appendedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterAppend, startIndex, appendedCount, epsilon, out newSectionSpacing);
            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (totalCount > appendedCount && appendedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check overlap of first point of new section with lastpoint of previous section (if exists)
            if (startIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterAppend[startIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterAppend[startIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterAppend.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

        public void OnInsert(IList<TimeSpan> valuesAfterInsert, int insertedIndex, int insertedCount)
        {
            if (!IsSortedAscending) return;

            // Check insertion for sorted
            bool newSectionSortedAscending = insertedCount == 1 || ArrayOperations.IsSortedAscending(valuesAfterInsert, insertedIndex, insertedCount);
            int endIndex = insertedIndex + insertedCount - 1;
            
            // Check insertion vs. previous / subsequent segments to check is sorted 
            IsSortedAscending = newSectionSortedAscending &&
                                (insertedIndex == 0 || valuesAfterInsert[insertedIndex] >= valuesAfterInsert[insertedIndex - 1]) &&
                                (endIndex >= (valuesAfterInsert.Count - 1) || valuesAfterInsert[endIndex] <= valuesAfterInsert[endIndex + 1]);

            if (!IsEvenlySpaced) return;

            double newSectionSpacing = 1.0;
            double epsilon = _currentSpacing * e;

            // Check new section evenly spaced
            bool newSectionEvenlySpaced = insertedCount == 1 || ArrayOperations.IsEvenlySpaced(valuesAfterInsert, insertedIndex, insertedCount, epsilon, out newSectionSpacing);

            if (!newSectionEvenlySpaced)
            {
                // If not, then we are no longer evenly spaced
                IsEvenlySpaced = false;
                return;
            }

            // Check new section spacing vs. old section spacing
            if (valuesAfterInsert.Count > insertedCount && insertedCount >= 2 && Math.Abs(_currentSpacing - newSectionSpacing) > epsilon)
            {
                IsEvenlySpaced = false;
                return;
            }

            // Check inserion vs. previous segment (if any)
            if (insertedIndex > 0)
            {
                var lastPoint = TxToDouble(valuesAfterInsert[insertedIndex - 1]);
                var nextPoint = TxToDouble(valuesAfterInsert[insertedIndex]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
            }

            // Check insertion vs. subsequent segment (if any)
            if (endIndex < (valuesAfterInsert.Count - 1))
            {
                var lastPoint = TxToDouble(valuesAfterInsert[endIndex]);
                var nextPoint = TxToDouble(valuesAfterInsert[endIndex + 1]);
                var diff = nextPoint - lastPoint;

                if (valuesAfterInsert.Count > 2)
                {
                    if (Math.Abs(diff - _currentSpacing) > epsilon)
                    {
                        IsEvenlySpaced = false;
                        return;
                    }
                }
                else if (diff == 0)
                {
                    IsEvenlySpaced = false;
                    return;
                }

                _currentSpacing = diff;
                return;
            }

            _currentSpacing = newSectionSpacing;
        }

		public override void Clear()
		{
		    base.Clear();
			_currentSpacing = 1.0;
		}

		private static double TxToDouble(TimeSpan xValue) { return xValue.Ticks; }
    }

	/// <summary>
	/// A type of DataDistributionCalculator which maye be used on List<T> or FIFO buffers. Has some known issues around Insert and overwrite sort/spacing detection
	/// For accurate sort/spacing detection when not using a FIFO, use the List*DataDistributionCalculator
	/// </summary>
	internal class TimeSpanDataDistributionCalculator : BaseDataDistributionCalculator<TimeSpan>
	{
		private const double MinVisibleRelativeXDiffError = 1.0 / 8000.0;
        double _lastXValue;
        double _firstXDiff;
        bool _firstXDiffIsValid = false;
        private double _minVisibleXDiffError;

	    public override void OnAppendXValue(ISeriesColumn<TimeSpan> xValues, TimeSpan newXValue, bool acceptsUnsortedData)
        {
            UpdateDataDistributionFlagsWhenAppendedXValue(xValues, newXValue, ((IList<TimeSpan>)xValues).Count - 1, acceptsUnsortedData);
        }

        public override void OnAppendXValues(ISeriesColumn<TimeSpan> xValues, int countBeforeAppending, IEnumerable<TimeSpan> newXValues, bool acceptsUnsortedData)
        {
            // Array case (Fastest)
            var array = newXValues as TimeSpan[];
            if (array != null)
            {
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, array, array.Length, acceptsUnsortedData);
                return;
            }

            // IList case (Fast)
            var iList = newXValues as IList<TimeSpan>;
            if (iList != null)
            {
                int count = iList.Count;
                var iListArray = iList.ToUncheckedList();
                UpdateDataDistributionFlagsWhenAppendedDataArray(xValues, countBeforeAppending, iListArray, count, acceptsUnsortedData);
                return;
            }

            // IEnumerable case (slowest)
            var enumerable = newXValues;
            int indexAfterAppending = countBeforeAppending;
            foreach (TimeSpan item in enumerable)
            {
                UpdateDataDistributionFlagsWhenAppendedXValue(xValues, item, indexAfterAppending, acceptsUnsortedData);
                indexAfterAppending++;
            }
        }

        public override void OnInsertXValue(ISeriesColumn<TimeSpan> xValues2, int indexWhereInserted, TimeSpan newXValue, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                var xValues = ((IList<TimeSpan>)xValues2);
                var xValuesCount = xValues.Count;

                if (indexWhereInserted == 0)
                {
                    // inserted at the beginning: it could still remain evenly spaced
                    if (xValuesCount > 1)
                    {
                        var xValue1 = xValues[1];
                        double xDiff = TxToDouble(xValue1) - TxToDouble(newXValue);
                        _firstXDiff = xDiff;
                        _firstXDiffIsValid = true;
                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            return;
                        }


                        if (DataIsEvenlySpaced)
                        {
                            if (_firstXDiffIsValid)
                            {
                                double error = xDiff - (TxToDouble(xValues[2]) - TxToDouble(xValue1));
                                if (error < 0) error = -error;
                                if (error > _minVisibleXDiffError)
                                {
                                    // data became unevenly spaced
                                    DataIsEvenlySpaced = false;
                                }
                            }
                        }
                    }
                }
                else if (indexWhereInserted == xValuesCount)
                {
                    // if inserted at the end
                    OnAppendXValue(xValues2, newXValue, acceptsUnsortedData);
                }
                else
                {
                    // inserted in the middle
                    DataIsEvenlySpaced = false;
                    if (DataIsSortedAscending)
                    {
                        if (indexWhereInserted > 0)
                        {
                            var previousXValue = xValues[indexWhereInserted - 1];
                            if (previousXValue > newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                        if (indexWhereInserted < xValuesCount - 1)
                        {
                            var nextXValue = xValues[indexWhereInserted + 1];
                            if (nextXValue < newXValue) 
							{
								DataIsSortedAscending = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataInsertedUnsortedWarning);
								}
							}
                        }
                    }
                }
            }
        }

        public override void OnInsertXValues(ISeriesColumn<TimeSpan> xValues2, int indexWhereInserted, int insertedCount, IEnumerable<TimeSpan> newXValues, bool acceptsUnsortedData)
        {
            var xValues = ((IList<TimeSpan>)xValues2);
            var xValuesCount = xValues.Count;
            if (indexWhereInserted + insertedCount == xValuesCount)
            {
                // inserted at the end: it could still remain evenly spaced
                OnAppendXValues(xValues2, xValuesCount - insertedCount, newXValues, acceptsUnsortedData);
            }
            else if (indexWhereInserted == 0)
            {
                // inserted at the beginning: it could still remain evenly spaced
                if (xValuesCount > 2)
                {
                    var lastXValue = xValues[1];
                    double firstXDiff = TxToDouble(lastXValue) - TxToDouble(xValues[0]);
                    _firstXDiff = firstXDiff;
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                    var minVisibleXDiffError = _minVisibleXDiffError;

                    // analyze XValues as IList, access it by index
                    for (int i = 2; i < insertedCount; i++)
                    {
                        var newXValue = TxToDouble(xValues[i]);
                        double xDiff = newXValue - _lastXValue;
                        _lastXValue = newXValue;

                        if (xDiff < 0)
                        {
                            DataIsSortedAscending = false;
                            DataIsEvenlySpaced = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }

                        if (DataIsEvenlySpaced)
                        {
                            double error = xDiff - firstXDiff;
                            if (error < 0) error = -error;
                            if (error > minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            { // inserted in the middle
                DataIsEvenlySpaced = false;
                if (DataIsSortedAscending)
                { // is it still sorted?
                    var previousXValue = xValues[indexWhereInserted - 1];
                    int maxIndex = indexWhereInserted + insertedCount + 1;
                    for (int i = indexWhereInserted; i < maxIndex; i++) // i points to range from first inserted item to first item after inserted batch
                    {
                        var xValue = xValues[i];
                        if (xValue < previousXValue)
                        {
                            DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataInsertedUnsortedWarning);
							}
                            break;
                        }
                        previousXValue = xValue;
                    }
                }
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedXValue(ISeriesColumn<TimeSpan> xValues, TimeSpan newXValue, int lastIndexAfterAppending, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                if (lastIndexAfterAppending > 0)
                {
                    double xDiff =  TxToDouble(newXValue) - _lastXValue;
                    if (xDiff < 0)
                    {
                        DataIsSortedAscending = false;
                        DataIsEvenlySpaced = false;
						if (!DataIsSortedAscending && !acceptsUnsortedData)
						{
							throw new InvalidOperationException(DataAppendedUnsortedWarning);
						}
                        return;
                    }

                    if (DataIsEvenlySpaced)
                    {
                        if (_firstXDiffIsValid)
                        {
                            double xDiffError = xDiff - _firstXDiff;
                            if (xDiffError < 0) xDiffError = -xDiffError;

                            if (xDiffError > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiffIsValid = true;
                            _firstXDiff = xDiff;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }
                _lastXValue = TxToDouble(newXValue);
            }
        }

        void UpdateDataDistributionFlagsWhenAppendedDataArray(IList<TimeSpan> xValues, int countBeforeAppending, TimeSpan[] newXValues, int newXValuesLength, bool acceptsUnsortedData)
        {
            if (DataIsSortedAscending || DataIsEvenlySpaced)
            {
                int arrayLength = newXValuesLength;
                double minVisibleXDiffError = _minVisibleXDiffError;

                if (countBeforeAppending > 0 && newXValuesLength > 0)
                {
                    var xDiff = TxToDouble(newXValues[0]) - _lastXValue;
                    if (DataIsSortedAscending)
                    {
                        // check sorting with previous batch
                        if (_lastXValue > TxToDouble(newXValues[0])) 
						{
							DataIsSortedAscending = false;
							if (!DataIsSortedAscending && !acceptsUnsortedData)
							{
								throw new InvalidOperationException(DataAppendedUnsortedWarning);
							}
						}
                    }

                    if (DataIsEvenlySpaced)
                    {
                        // check distance with previous batch
                        if (_firstXDiffIsValid && newXValuesLength > 0)
                        {
                            var error = xDiff - _firstXDiff;
                            if (error < 0) error = -error;
                            if (error > _minVisibleXDiffError)
                            {
                                // data became unevenly spaced
                                DataIsEvenlySpaced = false;
                            }
                        }
                        else
                        {
                            _firstXDiff = xDiff;
                            _firstXDiffIsValid = true;
                            _minVisibleXDiffError = xDiff * MinVisibleRelativeXDiffError;
                        }
                    }
                }

                bool nativeCodeHasWorked = false;
                //#if !SILVERLIGHT
                //                var nativeDataDistributionCalculator = Utility.UnmanagedDll.DllLoader.NativeDataDistributionCalculator;
                //                if (nativeDataDistributionCalculator != null)
                //                {
                //                    nativeDataDistributionCalculator.IsDataEvenlySpacedAndSorted_float(newXValues, ref DataIsEvenlySpaced,
                //                                                                                        ref DataIsSortedAscending);
                //                    nativeCodeHasWorked = true;
                //                }
                //#endif

                if (nativeCodeHasWorked == false)
                { // do it in C# if native module is unavailable
                    unchecked
                    {
                        // cache variables into stack or CPU registers
                        var lastXValue = TxToDouble(newXValues[0]);
                        var firstXDiff = _firstXDiff;
                        var firstXDiffIsValid = _firstXDiffIsValid;

                        for (int i = 1; i < arrayLength; i++)
                        {
                            var newXValue = TxToDouble(newXValues[i]);
                            double xDiff = newXValue - lastXValue;
                            if (xDiff < 0)
                            {
                                DataIsSortedAscending = false;
                                DataIsEvenlySpaced = false;
								if (!DataIsSortedAscending && !acceptsUnsortedData)
								{
									throw new InvalidOperationException(DataAppendedUnsortedWarning);
								}
                                break;
                            }
                            lastXValue = newXValue;

                            if (DataIsEvenlySpaced)
                            {
                                if (firstXDiffIsValid)
                                {
                                    double error = xDiff - firstXDiff;
                                    if (error < 0) error = -error;
                                    if (error > minVisibleXDiffError)
                                    {
                                        // data became unevenly spaced
                                        DataIsEvenlySpaced = false;
                                    }
                                }
                                else
                                {
                                    firstXDiff = xDiff;
                                    firstXDiffIsValid = true;
                                }
                            }
                        }

                        _lastXValue = lastXValue;
                        _firstXDiffIsValid = firstXDiffIsValid;
                        _firstXDiff = firstXDiff;
                    }
                }
                _lastXValue = TxToDouble(newXValues[arrayLength - 1]);
                if (_firstXDiffIsValid == false && arrayLength > 1)
                {
                    _firstXDiff = _lastXValue - TxToDouble(newXValues[arrayLength - 2]);
                    _firstXDiffIsValid = true;
                    _minVisibleXDiffError = _firstXDiff * MinVisibleRelativeXDiffError;
                }
            }
        }

		private static double TxToDouble(TimeSpan xValue) { return xValue.Ticks; }
	}

	#endregion	
}

// ReSharper Restore All