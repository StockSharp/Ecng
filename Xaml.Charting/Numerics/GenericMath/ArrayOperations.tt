<#@ template language="C#" #>
<# 
var tTypes = new System.Collections.Generic.List<string> {"Decimal", "Double", "Single", "Int32", "UInt32", "Int64", "UInt64", "Int16", "UInt16", "Byte", "SByte", "DateTime", "TimeSpan"};
 #>
// *************************************************************************************
// ULTRACHART™ © Copyright ulc software Services Ltd. 2011-2014. All rights reserved.
//  
// Web: http://www.ultrachart.com
// Support: support@ultrachart.com
// 
// Resamplers.cs is part of Ultrachart, a High Performance WPF & Silverlight Chart. 
// For full terms and conditions of the license, see http://www.ultrachart.com/ultrachart-eula/
// 
// This source code is protected by international copyright law. Unauthorized
// reproduction, reverse-engineering, or distribution of all or any portion of
// this source code is strictly prohibited.
// 
// This source code contains confidential and proprietary trade secrets of
// ulc software Services Ltd., and should at no time be copied, transferred, sold,
// distributed or made available without express written permission.
// *************************************************************************************
using System;
using System.Collections.Generic;
using Ecng.Xaml.Charting.Common.Extensions;
// ReSharper Disable All

namespace Ecng.Xaml.Charting.Numerics.GenericMath
{
	internal static class ArrayOperations
    {
		private static readonly IDictionary<Type, object> _genericArrayHelpers = new Dictionary<Type, object>();

		static ArrayOperations()
		{
			// Register generic helpers<# foreach (string tType in tTypes){#>	
			_genericArrayHelpers.Add(typeof(<#= tType #>), new <#= tType #>GenericArrayHelper());<#}#>	
		}

		/// <returns>T.MinValue if there are no elements in input. This is required for joining ranges of dataseries</returns>
        internal static T Maximum<T>(IEnumerable<T> enumerable)
        {
            var array = enumerable as T[];
            if (array != null)
            {
                return Maximum<T>(array, 0, array.Length);
            }

            var iList = enumerable as IList<T>;
            if (iList != null)
            {
                return Maximum<T>(iList.ToUncheckedList(), 0, iList.Count);
            }

            var math = GenericMathFactory.New<T>();
            var max = math.MinValue;
            foreach (var item in enumerable)
                max = math.Max(max, item);

            return max;
        }

		/// <returns>T.MaxValue if there are no elements in input. This is required for joining ranges of dataseries</returns>
        internal static T Minimum<T>(IEnumerable<T> enumerable)
        {
          var math = GenericMathFactory.New<T>();

          return Minimum(enumerable, math.Min);
        }

        internal static T MinGreaterThan<T>(IEnumerable<T> enumerable, T floor)
        {
            var math = GenericMathFactory.New<T>();

            return Minimum(enumerable, (a,b) => math.MinGreaterThan(floor, a, b));
        }

        internal static T Minimum<T>(IEnumerable<T> enumerable, Func<T,T,T> minFunc)
        {
            var array = enumerable as T[];
            if (array != null)
            {
                return Minimum<T>(array, 0, array.Length, minFunc);
            }

            var iList = enumerable as IList<T>;
            if (iList != null)
            {
                return Minimum<T>(iList.ToUncheckedList(), 0, iList.Count, minFunc);
            }

            var math = GenericMathFactory.New<T>();
            var min = math.MaxValue;
            foreach (var item in enumerable)
                min = minFunc(min, item);

            return min;
        }

	
        /// <summary>
        /// Fast generic computation of the Min and Max of an enumerable 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="enumerable">The input enumerable.</param>
        /// <param name="min">T.MaxValue if there are no elements in input. This is required for joining ranges of dataseries</param>
        /// <param name="max">T.MinValue if there are no elements in input. This is required for joining ranges of dataseries</param>
        public static void MinMax<T>(IEnumerable<T> enumerable, out T min, out T max)
        {
            var array = enumerable as T[];
            if (array != null)
            {
                MinMax<T>(array, 0, array.Length, out min, out max);
                return;
            }

            var iList = enumerable as IList<T>;
            if (iList != null)
            {
                MinMax<T>(iList.ToUncheckedList(), 0, iList.Count, out min, out max);
                return;
            }

            var math = GenericMathFactory.New<T>();
            max = math.MinValue;
            min = math.MaxValue;
            foreach (var item in enumerable)
            {
                max = math.Max(max, item);
                min = math.Min(min, item);
            }            
        }

		public static bool IsSortedAscending<T>(IEnumerable<T> enumerable)
			where T:IComparable
		{
			var array = enumerable as T[];
            if (array != null)
            {
                return IsSortedAscending<T>(array, 0, array.Length);
            }

            var iList = enumerable as IList<T>;
            if (iList != null)
            {
                return IsSortedAscending<T>(iList.ToUncheckedList(), 0, iList.Count);
            }

			var itr = enumerable.GetEnumerator();
			if (!itr.MoveNext()) return true;
			var last = itr.Current;
			
			while(itr.MoveNext())
			{
				if (itr.Current.CompareTo(last) < 0) 
					return false;

				last = itr.Current;
			}
			return true;
		}

        public static bool IsEvenlySpaced<T>(IEnumerable<T> enumerable, double epsilon, out double spacing)
			where T:IComparable
		{
			var array = enumerable as T[];
            if (array != null)
            {
                return IsEvenlySpaced<T>(array, 0, array.Length, epsilon, out spacing);
            }

            var iList = enumerable as IList<T>;
            if (iList != null)
            {
                return IsEvenlySpaced<T>(iList.ToUncheckedList(), 0, iList.Count, epsilon, out spacing);
            }

            var math = GenericMathFactory.New<T>();
			var itr = enumerable.GetEnumerator();
			if (!itr.MoveNext()) 
			{
				spacing = 1.0;
				return true;
			}
			double last = math.ToDouble(itr.Current);
            if (!itr.MoveNext()) 
			{
				spacing = 1.0;
				return true;
			}
            double current = math.ToDouble(itr.Current);
            double lastDiff = current - last;
			last = current;

			while(itr.MoveNext())
			{
				current = math.ToDouble(itr.Current);
                double diff = current - last;
                if (Math.Abs(lastDiff - diff) > epsilon) 
				{
					spacing = Math.Abs(lastDiff);
					return false;
				}
                lastDiff = diff;
                last = current;
			}
			spacing = Math.Abs(lastDiff);
			return true;
		}

		/// <returns>T.MaxValue if there are no elements in input. This is required for joining ranges of dataseries</returns>
        internal static T Minimum<T>(T[] array, int startIndex, int count)
		{
            var math = GenericMathFactory.New<T>();

            return Minimum(array, startIndex, count, math.Min);
		}		

		// TODO {ABT} this one can go into generic helpers
		/// <returns>T.MaxValue if there are no elements in input. This is required for joining ranges of dataseries</returns>
        internal static T Minimum<T>(T[] array, int startIndex, int count, Func<T,T,T> minFunc)
        {
            var math = GenericMathFactory.New<T>();

            T min = math.MaxValue;

            int i = startIndex;
            int iMax = count;

            if (array.Length > 16)
            {
                // Unroll loop in blocks of 16 to calculate max
                int iMax2 = iMax - iMax % 16;
                for (; i != iMax2; )
                {
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                    min = minFunc(min, array[i]); ++i;
                }
            }

            // Complete loop
            for (; i != iMax; )
            {
                min = minFunc(min, array[i]); ++i;
            }

            return min;
        }

		/// <returns>T.MinValue if there are no elements in input. This is required for joining ranges of dataseries</returns>
        internal static T Maximum<T>(T[] array, int startIndex, int count)
		{
			return ((IGenericArrayHelper<T>)_genericArrayHelpers[typeof(T)]).Maximum(array, startIndex, count);
		}

		/// <summary>
        /// Fast generic computation of the Min and Max of an array 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="array">The input array.</param>
        /// <param name="startIndex">The start index.</param>
        /// <param name="count">The count.</param>
        /// <param name="min">T.MaxValue if there are no elements in input. This is required for joining ranges of dataseries</param>
        /// <param name="max">T.MinValue if there are no elements in input. This is required for joining ranges of dataseries</param>
        internal static void MinMax<T>(T[] array, int startIndex, int count, out T min, out T max)
        {
			((IGenericArrayHelper<T>)_genericArrayHelpers[typeof(T)]).MinMax(array, startIndex, count, out min, out max);
		}

		/// <summary>
        /// Fast generic computation of whether an array is sorted
        /// </summary>
        internal static bool IsSortedAscending<T>(T[] array, int startIndex, int count)
        {
            return ((IGenericArrayHelper<T>)_genericArrayHelpers[typeof(T)]).IsSortedAscending(array, startIndex, count);
        }

		/// <summary>
        /// Fast generic computation of whether a list is sorted
        /// </summary>
        internal static bool IsSortedAscending<T>(IList<T> items, int startIndex, int count)
        {
            return ((IGenericArrayHelper<T>)_genericArrayHelpers[typeof(T)]).IsSortedAscending(items, startIndex, count);
        }

		/// <summary>
        /// Fast generic computation of whether an array is evenly spaced
        /// </summary>
        internal static bool IsEvenlySpaced<T>(T[] array, int startIndex, int count, double epsilon, out double spacing)
        {
            return ((IGenericArrayHelper<T>)_genericArrayHelpers[typeof(T)]).IsEvenlySpaced(array, startIndex, count, epsilon, out spacing);
        }

		/// <summary>
        /// Fast generic computation of whether an array is evenly spaced
        /// </summary>
        internal static bool IsEvenlySpaced<T>(IList<T> items, int startIndex, int count, double epsilon, out double spacing)
        {
            return ((IGenericArrayHelper<T>)_genericArrayHelpers[typeof(T)]).IsEvenlySpaced(items, startIndex, count, epsilon, out spacing);
        }

		/// <summary>Interface to fast autogenerated generic Min Max helpers</summary>
		private interface IGenericArrayHelper<T>
		{
			T Maximum(T[] array, int startIndex, int count);
			void MinMax(T[] array, int startIndex, int count, out T min, out T max);
			bool IsSortedAscending(T[] array, int startIndex, int count);
			bool IsSortedAscending(IList<T> items, int startIndex, int count);
            bool IsEvenlySpaced(T[] array, int startIndex, int count, double epsilon, out double spacing);
			bool IsEvenlySpaced(IList<T> items, int startIndex, int count, double epsilon, out double spacing);
		}
<# 
foreach (string tType in tTypes)
{ 	
#>			
		#region AutoGenerated <#= tType #>GenericArrayHelper
#if !SILVERLIGHT
		unsafe
#endif
		class <#= tType #>GenericArrayHelper : IGenericArrayHelper<<#= tType #>>
		{
			public <#= tType #> Maximum(<#= tType #>[] array, int startIndex, int count)
			{
				unchecked
				{
					<#= tType #> max = GenericMathFactory.New<<#= tType #>>().MinValue;

					// Sanity checks
					if (count == 0) return max; 
					if (count == 1)
					{
						max = array[0];
						return max;
					}

					int i = startIndex;
					int iMax = count;
					<#= tType #> current;

					#if !SILVERLIGHT
					fixed (<#= tType #> * ptr = &array[0])
					{
					#else
					var ptr = array;
					#endif

					if (array.Length > 16)
					{
						// Unroll loop in blocks of 16 to calculate max
						int iMax2 = iMax - iMax%16;
						for (; i != iMax2; )
						{
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
							current = ptr[i]; max = current > max ? current : max; ++i;
						}
					}

					// Complete loop
					for (; i != iMax; )
					{
						current = ptr[i]; max = current > max ? current : max; ++i;
					}

					return max;

					#if !SILVERLIGHT
					}
					#endif
				}
			}

			public void MinMax(<#= tType #>[] array, int startIndex, int count, out <#= tType #> min, out <#= tType #> max)
			{
				unchecked
				{
					var math = GenericMathFactory.New<<#= tType #>>();
					max = math.MinValue;
					min = math.MaxValue;

					// Sanity checks
					if (count == 0) return;
					if (count == 1)
					{
						min = array[0];
						max = array[0];
						return;
					}

					<#= tType #> current;

					int i = startIndex;
					int iMax = count;

					#if !SILVERLIGHT
					fixed (<#= tType #> * ptr = &array[0])
					{
					#else
					var ptr = array;
					#endif

					if (array.Length > 16)
					{
						// Unroll loop in blocks of 16 to calculate min, max
						int iMax2 = iMax - iMax % 16;
                
						for (; i != iMax2; )
						{
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
							current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
						}
					}

					// Complete loop
					for (; i != iMax; )
					{
						current = ptr[i]; max = current > max ? current : max; min = current < min ? current : min; ++i;
					}

					#if !SILVERLIGHT
					}
					#endif
				}
			}

			public bool IsSortedAscending(<#= tType #>[] array, int startIndex, int count)
			{
				unchecked
				{
                    int iMax = startIndex + count;
					int i = startIndex;

#if !SILVERLIGHT
					fixed (<#= tType #> * ptr = &array[0]) {
#else
					var ptr = array;
#endif

						<#= tType #> current;
						<#= tType #> last = ptr[i++];

						for (; i < iMax; ++i)
						{
							current = ptr[i];
							if (current < last) return false;
							last = current;
						}

					#if !SILVERLIGHT
					}
					#endif
				}

				return true;
			}

			public bool IsSortedAscending(IList<<#= tType #>> items, int startIndex, int count)
			{
				if (count <= 1)
				{
					return true;
				}

				return IsSortedAscending(items.ToUncheckedList(), startIndex, count);
			}

			public bool IsEvenlySpaced(<#= tType #>[] array, int startIndex, int count, double epsilon, out double spacing)
			{
                if (count <= 1)
				{
					spacing = 1.0;
					return true;
				}

				if (count == 2)
				{
					spacing = Math.Abs(TxToDouble(array[startIndex]) - TxToDouble(array[startIndex+1]));
					return true;
				}

                int iMax = startIndex + count;
				unchecked
				{
#if !SILVERLIGHT
					fixed (<#= tType #> * ptr = &array[0]) {
#else
					var ptr = array;
#endif
						
                        double last = TxToDouble(ptr[startIndex++]);
                        double current = TxToDouble(ptr[startIndex++]);
                        double lastDiff = current - last;
                        last = current;

						for (int i = startIndex; i != iMax; ++i)
						{
                            current = TxToDouble(ptr[i]);
							double diff = current - last;
                            if (Math.Abs(lastDiff - diff) > epsilon) 
							{
								spacing = Math.Abs(lastDiff);
								return false;
							}
                            lastDiff = diff;
                            last = current;
						}

						spacing = Math.Abs(lastDiff);

					#if !SILVERLIGHT
					}
					#endif
				}

				return true;
			}

			public bool IsEvenlySpaced(IList<<#= tType #>> items, int startIndex, int count, double epsilon, out double spacing)
			{
			    if (count <= 1)
				{
					spacing = 1.0;
					return true;
				}

				if (count == 2)
				{
					spacing = Math.Abs(TxToDouble(items[startIndex]) - TxToDouble(items[startIndex+1]));
					return true;
				}

				return IsEvenlySpaced(items.ToUncheckedList(), startIndex, count, epsilon, out spacing);
			}

            private static double TxToDouble(<#= tType #> xValue) {<#if(tType == "DateTime" || tType == "TimeSpan"){#> return xValue.Ticks;<#}else{#> return (double)xValue;<#}#> }
		}	
		#endregion	
<# 
}	
#>
}
    }
// ReSharper Restore All
