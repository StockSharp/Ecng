// *************************************************************************************
// ULTRACHART™ © Copyright ulc software Services Ltd. 2011-2014. All rights reserved.
//  
// Web: http://www.ultrachart.com
// Support: support@ultrachart.com
// 
// Resamplers.cs is part of Ultrachart, a High Performance WPF & Silverlight Chart. 
// For full terms and conditions of the license, see http://www.ultrachart.com/ultrachart-eula/
// 
// This source code is protected by international copyright law. Unauthorized
// reproduction, reverse-engineering, or distribution of all or any portion of
// this source code is strictly prohibited.
// 
// This source code contains confidential and proprietary trade secrets of
// ulc software Services Ltd., and should at no time be copied, transferred, sold,
// distributed or made available without express written permission.
// *************************************************************************************
using System;
using System.Collections;
using System.Collections.Generic;
using Ecng.Xaml.Charting.Common.Extensions;
using Ecng.Xaml.Charting.Model.DataSeries;
using Ecng.Xaml.Charting.Numerics.GenericMath;
// ReSharper Disable All

// <autogenerated>
// This code is autogenerated by Resamplers.tt. Do not modify this code
// </autogenerated>
namespace Ecng.Xaml.Charting.Numerics.PointResamplers
{	
	/// <summary>
    /// Instantiates <see cref="IPointResampler"/> instances
    /// </summary>
    public class PointResamplerFactory : IPointResamplerFactory
    {
		private static readonly Dictionary<Type, Dictionary<Type, IPointResampler>> _resamplers = new Dictionary<Type, Dictionary<Type, IPointResampler>>();
		static PointResamplerFactory()
		{
			Dictionary<Type, IPointResampler> yDict = null;
	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(Double), yDict);
			yDict.Add(typeof(Double), new DoubleDoubleResampler());
			yDict.Add(typeof(Single), new DoubleSingleResampler());
			yDict.Add(typeof(Int32), new DoubleInt32Resampler());
			yDict.Add(typeof(UInt32), new DoubleUInt32Resampler());
			yDict.Add(typeof(Int64), new DoubleInt64Resampler());
			yDict.Add(typeof(UInt64), new DoubleUInt64Resampler());
			yDict.Add(typeof(Int16), new DoubleInt16Resampler());
			yDict.Add(typeof(UInt16), new DoubleUInt16Resampler());
			yDict.Add(typeof(Byte), new DoubleByteResampler());
			yDict.Add(typeof(SByte), new DoubleSByteResampler());
	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(Single), yDict);
			yDict.Add(typeof(Double), new SingleDoubleResampler());
			yDict.Add(typeof(Single), new SingleSingleResampler());
			yDict.Add(typeof(Int32), new SingleInt32Resampler());
			yDict.Add(typeof(UInt32), new SingleUInt32Resampler());
			yDict.Add(typeof(Int64), new SingleInt64Resampler());
			yDict.Add(typeof(UInt64), new SingleUInt64Resampler());
			yDict.Add(typeof(Int16), new SingleInt16Resampler());
			yDict.Add(typeof(UInt16), new SingleUInt16Resampler());
			yDict.Add(typeof(Byte), new SingleByteResampler());
			yDict.Add(typeof(SByte), new SingleSByteResampler());
	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(Int32), yDict);
			yDict.Add(typeof(Double), new Int32DoubleResampler());
			yDict.Add(typeof(Single), new Int32SingleResampler());
			yDict.Add(typeof(Int32), new Int32Int32Resampler());
			yDict.Add(typeof(UInt32), new Int32UInt32Resampler());
			yDict.Add(typeof(Int64), new Int32Int64Resampler());
			yDict.Add(typeof(UInt64), new Int32UInt64Resampler());
			yDict.Add(typeof(Int16), new Int32Int16Resampler());
			yDict.Add(typeof(UInt16), new Int32UInt16Resampler());
			yDict.Add(typeof(Byte), new Int32ByteResampler());
			yDict.Add(typeof(SByte), new Int32SByteResampler());
	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(UInt32), yDict);
			yDict.Add(typeof(Double), new UInt32DoubleResampler());
			yDict.Add(typeof(Single), new UInt32SingleResampler());
			yDict.Add(typeof(Int32), new UInt32Int32Resampler());
			yDict.Add(typeof(UInt32), new UInt32UInt32Resampler());
			yDict.Add(typeof(Int64), new UInt32Int64Resampler());
			yDict.Add(typeof(UInt64), new UInt32UInt64Resampler());
			yDict.Add(typeof(Int16), new UInt32Int16Resampler());
			yDict.Add(typeof(UInt16), new UInt32UInt16Resampler());
			yDict.Add(typeof(Byte), new UInt32ByteResampler());
			yDict.Add(typeof(SByte), new UInt32SByteResampler());
	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(Int64), yDict);
			yDict.Add(typeof(Double), new Int64DoubleResampler());
			yDict.Add(typeof(Single), new Int64SingleResampler());
			yDict.Add(typeof(Int32), new Int64Int32Resampler());
			yDict.Add(typeof(UInt32), new Int64UInt32Resampler());
			yDict.Add(typeof(Int64), new Int64Int64Resampler());
			yDict.Add(typeof(UInt64), new Int64UInt64Resampler());
			yDict.Add(typeof(Int16), new Int64Int16Resampler());
			yDict.Add(typeof(UInt16), new Int64UInt16Resampler());
			yDict.Add(typeof(Byte), new Int64ByteResampler());
			yDict.Add(typeof(SByte), new Int64SByteResampler());
	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(UInt64), yDict);
			yDict.Add(typeof(Double), new UInt64DoubleResampler());
			yDict.Add(typeof(Single), new UInt64SingleResampler());
			yDict.Add(typeof(Int32), new UInt64Int32Resampler());
			yDict.Add(typeof(UInt32), new UInt64UInt32Resampler());
			yDict.Add(typeof(Int64), new UInt64Int64Resampler());
			yDict.Add(typeof(UInt64), new UInt64UInt64Resampler());
			yDict.Add(typeof(Int16), new UInt64Int16Resampler());
			yDict.Add(typeof(UInt16), new UInt64UInt16Resampler());
			yDict.Add(typeof(Byte), new UInt64ByteResampler());
			yDict.Add(typeof(SByte), new UInt64SByteResampler());
	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(Int16), yDict);
			yDict.Add(typeof(Double), new Int16DoubleResampler());
			yDict.Add(typeof(Single), new Int16SingleResampler());
			yDict.Add(typeof(Int32), new Int16Int32Resampler());
			yDict.Add(typeof(UInt32), new Int16UInt32Resampler());
			yDict.Add(typeof(Int64), new Int16Int64Resampler());
			yDict.Add(typeof(UInt64), new Int16UInt64Resampler());
			yDict.Add(typeof(Int16), new Int16Int16Resampler());
			yDict.Add(typeof(UInt16), new Int16UInt16Resampler());
			yDict.Add(typeof(Byte), new Int16ByteResampler());
			yDict.Add(typeof(SByte), new Int16SByteResampler());
	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(UInt16), yDict);
			yDict.Add(typeof(Double), new UInt16DoubleResampler());
			yDict.Add(typeof(Single), new UInt16SingleResampler());
			yDict.Add(typeof(Int32), new UInt16Int32Resampler());
			yDict.Add(typeof(UInt32), new UInt16UInt32Resampler());
			yDict.Add(typeof(Int64), new UInt16Int64Resampler());
			yDict.Add(typeof(UInt64), new UInt16UInt64Resampler());
			yDict.Add(typeof(Int16), new UInt16Int16Resampler());
			yDict.Add(typeof(UInt16), new UInt16UInt16Resampler());
			yDict.Add(typeof(Byte), new UInt16ByteResampler());
			yDict.Add(typeof(SByte), new UInt16SByteResampler());
	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(Byte), yDict);
			yDict.Add(typeof(Double), new ByteDoubleResampler());
			yDict.Add(typeof(Single), new ByteSingleResampler());
			yDict.Add(typeof(Int32), new ByteInt32Resampler());
			yDict.Add(typeof(UInt32), new ByteUInt32Resampler());
			yDict.Add(typeof(Int64), new ByteInt64Resampler());
			yDict.Add(typeof(UInt64), new ByteUInt64Resampler());
			yDict.Add(typeof(Int16), new ByteInt16Resampler());
			yDict.Add(typeof(UInt16), new ByteUInt16Resampler());
			yDict.Add(typeof(Byte), new ByteByteResampler());
			yDict.Add(typeof(SByte), new ByteSByteResampler());
	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(SByte), yDict);
			yDict.Add(typeof(Double), new SByteDoubleResampler());
			yDict.Add(typeof(Single), new SByteSingleResampler());
			yDict.Add(typeof(Int32), new SByteInt32Resampler());
			yDict.Add(typeof(UInt32), new SByteUInt32Resampler());
			yDict.Add(typeof(Int64), new SByteInt64Resampler());
			yDict.Add(typeof(UInt64), new SByteUInt64Resampler());
			yDict.Add(typeof(Int16), new SByteInt16Resampler());
			yDict.Add(typeof(UInt16), new SByteUInt16Resampler());
			yDict.Add(typeof(Byte), new SByteByteResampler());
			yDict.Add(typeof(SByte), new SByteSByteResampler());
	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(DateTime), yDict);
			yDict.Add(typeof(Double), new DateTimeDoubleResampler());
			yDict.Add(typeof(Single), new DateTimeSingleResampler());
			yDict.Add(typeof(Int32), new DateTimeInt32Resampler());
			yDict.Add(typeof(UInt32), new DateTimeUInt32Resampler());
			yDict.Add(typeof(Int64), new DateTimeInt64Resampler());
			yDict.Add(typeof(UInt64), new DateTimeUInt64Resampler());
			yDict.Add(typeof(Int16), new DateTimeInt16Resampler());
			yDict.Add(typeof(UInt16), new DateTimeUInt16Resampler());
			yDict.Add(typeof(Byte), new DateTimeByteResampler());
			yDict.Add(typeof(SByte), new DateTimeSByteResampler());
	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(TimeSpan), yDict);
			yDict.Add(typeof(Double), new TimeSpanDoubleResampler());
			yDict.Add(typeof(Single), new TimeSpanSingleResampler());
			yDict.Add(typeof(Int32), new TimeSpanInt32Resampler());
			yDict.Add(typeof(UInt32), new TimeSpanUInt32Resampler());
			yDict.Add(typeof(Int64), new TimeSpanInt64Resampler());
			yDict.Add(typeof(UInt64), new TimeSpanUInt64Resampler());
			yDict.Add(typeof(Int16), new TimeSpanInt16Resampler());
			yDict.Add(typeof(UInt16), new TimeSpanUInt16Resampler());
			yDict.Add(typeof(Byte), new TimeSpanByteResampler());
			yDict.Add(typeof(SByte), new TimeSpanSByteResampler());
		}

        /// <summary>
        /// Instantiates a <see cref="IPointResampler"/> instance for the combination of <typeparamref name="TX"/> and <typeparamref name="TY"/>
        /// </summary>
        public IPointResampler GetPointResampler<TX, TY>() where TX : IComparable where TY : IComparable
        {
            var yType = typeof(TY);
            var xType = typeof(TX);

			try
			{
				return _resamplers[xType][yType];
			}
			catch(Exception caught)
			{
				throw new InvalidOperationException(string.Format("No resampler exists for the combination of TX={0} and TY={1}. Please contact support", xType, yType));
			}
        }

	
		#region Autogenerated Resampler for TX=System.Double, TY=System.Double
		private class DoubleDoubleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Double> xColumn = xValues as IList<Double>;
				IList<Double> yColumn = yValues as IList<Double>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Double> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Double>();

					Double min = yMath.MaxValue;
					Double max = yMath.MinValue;
					Double current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Double> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Double> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Double* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Double* ySrcStart = &yItems.Array[startIndex])
								{
									Double* xSrc = xSrcStart;
									Double* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Double> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Double> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Double> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Double> xDoubleColumn, IList<Double> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Double* xSrcStart = &itemsX[startIndex])
						fixed (Double* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Double* xSrc = xSrcStart;
							Double* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Double xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Double, TY=System.Single
		private class DoubleSingleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Double> xColumn = xValues as IList<Double>;
				IList<Single> yColumn = yValues as IList<Single>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Double> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Single>();

					Single min = yMath.MaxValue;
					Single max = yMath.MinValue;
					Single current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Double> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Single> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Double* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Single* ySrcStart = &yItems.Array[startIndex])
								{
									Double* xSrc = xSrcStart;
									Single* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Double> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Double> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Double> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Double> xDoubleColumn, IList<Single> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Double* xSrcStart = &itemsX[startIndex])
						fixed (Single* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Double* xSrc = xSrcStart;
							Single* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Double xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Double, TY=System.Int32
		private class DoubleInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Double> xColumn = xValues as IList<Double>;
				IList<Int32> yColumn = yValues as IList<Int32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Double> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int32>();

					Int32 min = yMath.MaxValue;
					Int32 max = yMath.MinValue;
					Int32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Double> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Double* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int32* ySrcStart = &yItems.Array[startIndex])
								{
									Double* xSrc = xSrcStart;
									Int32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Double> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Double> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Double> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Double> xDoubleColumn, IList<Int32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Double* xSrcStart = &itemsX[startIndex])
						fixed (Int32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Double* xSrc = xSrcStart;
							Int32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Double xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Double, TY=System.UInt32
		private class DoubleUInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Double> xColumn = xValues as IList<Double>;
				IList<UInt32> yColumn = yValues as IList<UInt32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Double> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt32>();

					UInt32 min = yMath.MaxValue;
					UInt32 max = yMath.MinValue;
					UInt32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Double> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Double* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt32* ySrcStart = &yItems.Array[startIndex])
								{
									Double* xSrc = xSrcStart;
									UInt32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Double> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Double> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Double> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Double> xDoubleColumn, IList<UInt32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Double* xSrcStart = &itemsX[startIndex])
						fixed (UInt32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Double* xSrc = xSrcStart;
							UInt32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Double xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Double, TY=System.Int64
		private class DoubleInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Double> xColumn = xValues as IList<Double>;
				IList<Int64> yColumn = yValues as IList<Int64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Double> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int64>();

					Int64 min = yMath.MaxValue;
					Int64 max = yMath.MinValue;
					Int64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Double> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Double* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int64* ySrcStart = &yItems.Array[startIndex])
								{
									Double* xSrc = xSrcStart;
									Int64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Double> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Double> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Double> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Double> xDoubleColumn, IList<Int64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Double* xSrcStart = &itemsX[startIndex])
						fixed (Int64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Double* xSrc = xSrcStart;
							Int64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Double xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Double, TY=System.UInt64
		private class DoubleUInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Double> xColumn = xValues as IList<Double>;
				IList<UInt64> yColumn = yValues as IList<UInt64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Double> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt64>();

					UInt64 min = yMath.MaxValue;
					UInt64 max = yMath.MinValue;
					UInt64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Double> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Double* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt64* ySrcStart = &yItems.Array[startIndex])
								{
									Double* xSrc = xSrcStart;
									UInt64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Double> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Double> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Double> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Double> xDoubleColumn, IList<UInt64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Double* xSrcStart = &itemsX[startIndex])
						fixed (UInt64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Double* xSrc = xSrcStart;
							UInt64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Double xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Double, TY=System.Int16
		private class DoubleInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Double> xColumn = xValues as IList<Double>;
				IList<Int16> yColumn = yValues as IList<Int16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Double> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int16>();

					Int16 min = yMath.MaxValue;
					Int16 max = yMath.MinValue;
					Int16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Double> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Double* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int16* ySrcStart = &yItems.Array[startIndex])
								{
									Double* xSrc = xSrcStart;
									Int16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Double> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Double> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Double> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Double> xDoubleColumn, IList<Int16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Double* xSrcStart = &itemsX[startIndex])
						fixed (Int16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Double* xSrc = xSrcStart;
							Int16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Double xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Double, TY=System.UInt16
		private class DoubleUInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Double> xColumn = xValues as IList<Double>;
				IList<UInt16> yColumn = yValues as IList<UInt16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Double> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt16>();

					UInt16 min = yMath.MaxValue;
					UInt16 max = yMath.MinValue;
					UInt16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Double> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Double* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt16* ySrcStart = &yItems.Array[startIndex])
								{
									Double* xSrc = xSrcStart;
									UInt16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Double> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Double> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Double> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Double> xDoubleColumn, IList<UInt16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Double* xSrcStart = &itemsX[startIndex])
						fixed (UInt16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Double* xSrc = xSrcStart;
							UInt16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Double xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Double, TY=System.Byte
		private class DoubleByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Double> xColumn = xValues as IList<Double>;
				IList<Byte> yColumn = yValues as IList<Byte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Double> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Byte>();

					Byte min = yMath.MaxValue;
					Byte max = yMath.MinValue;
					Byte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Double> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Byte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Double* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Byte* ySrcStart = &yItems.Array[startIndex])
								{
									Double* xSrc = xSrcStart;
									Byte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Double> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Double> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Double> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Double> xDoubleColumn, IList<Byte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Double* xSrcStart = &itemsX[startIndex])
						fixed (Byte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Double* xSrc = xSrcStart;
							Byte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Double xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Double, TY=System.SByte
		private class DoubleSByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Double> xColumn = xValues as IList<Double>;
				IList<SByte> yColumn = yValues as IList<SByte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Double> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<SByte>();

					SByte min = yMath.MaxValue;
					SByte max = yMath.MinValue;
					SByte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Double> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<SByte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Double* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (SByte* ySrcStart = &yItems.Array[startIndex])
								{
									Double* xSrc = xSrcStart;
									SByte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Double> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Double> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Double> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Double> xDoubleColumn, IList<SByte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Double* xSrcStart = &itemsX[startIndex])
						fixed (SByte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Double* xSrc = xSrcStart;
							SByte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Double xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Single, TY=System.Double
		private class SingleDoubleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Single> xColumn = xValues as IList<Single>;
				IList<Double> yColumn = yValues as IList<Double>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Single> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Double>();

					Double min = yMath.MaxValue;
					Double max = yMath.MinValue;
					Double current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Single> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Double> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Single* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Double* ySrcStart = &yItems.Array[startIndex])
								{
									Single* xSrc = xSrcStart;
									Double* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Single> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Single> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Single> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Single> xDoubleColumn, IList<Double> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Single* xSrcStart = &itemsX[startIndex])
						fixed (Double* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Single* xSrc = xSrcStart;
							Double* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Single xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Single, TY=System.Single
		private class SingleSingleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Single> xColumn = xValues as IList<Single>;
				IList<Single> yColumn = yValues as IList<Single>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Single> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Single>();

					Single min = yMath.MaxValue;
					Single max = yMath.MinValue;
					Single current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Single> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Single> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Single* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Single* ySrcStart = &yItems.Array[startIndex])
								{
									Single* xSrc = xSrcStart;
									Single* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Single> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Single> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Single> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Single> xDoubleColumn, IList<Single> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Single* xSrcStart = &itemsX[startIndex])
						fixed (Single* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Single* xSrc = xSrcStart;
							Single* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Single xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Single, TY=System.Int32
		private class SingleInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Single> xColumn = xValues as IList<Single>;
				IList<Int32> yColumn = yValues as IList<Int32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Single> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int32>();

					Int32 min = yMath.MaxValue;
					Int32 max = yMath.MinValue;
					Int32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Single> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Single* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int32* ySrcStart = &yItems.Array[startIndex])
								{
									Single* xSrc = xSrcStart;
									Int32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Single> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Single> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Single> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Single> xDoubleColumn, IList<Int32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Single* xSrcStart = &itemsX[startIndex])
						fixed (Int32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Single* xSrc = xSrcStart;
							Int32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Single xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Single, TY=System.UInt32
		private class SingleUInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Single> xColumn = xValues as IList<Single>;
				IList<UInt32> yColumn = yValues as IList<UInt32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Single> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt32>();

					UInt32 min = yMath.MaxValue;
					UInt32 max = yMath.MinValue;
					UInt32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Single> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Single* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt32* ySrcStart = &yItems.Array[startIndex])
								{
									Single* xSrc = xSrcStart;
									UInt32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Single> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Single> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Single> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Single> xDoubleColumn, IList<UInt32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Single* xSrcStart = &itemsX[startIndex])
						fixed (UInt32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Single* xSrc = xSrcStart;
							UInt32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Single xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Single, TY=System.Int64
		private class SingleInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Single> xColumn = xValues as IList<Single>;
				IList<Int64> yColumn = yValues as IList<Int64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Single> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int64>();

					Int64 min = yMath.MaxValue;
					Int64 max = yMath.MinValue;
					Int64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Single> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Single* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int64* ySrcStart = &yItems.Array[startIndex])
								{
									Single* xSrc = xSrcStart;
									Int64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Single> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Single> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Single> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Single> xDoubleColumn, IList<Int64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Single* xSrcStart = &itemsX[startIndex])
						fixed (Int64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Single* xSrc = xSrcStart;
							Int64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Single xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Single, TY=System.UInt64
		private class SingleUInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Single> xColumn = xValues as IList<Single>;
				IList<UInt64> yColumn = yValues as IList<UInt64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Single> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt64>();

					UInt64 min = yMath.MaxValue;
					UInt64 max = yMath.MinValue;
					UInt64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Single> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Single* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt64* ySrcStart = &yItems.Array[startIndex])
								{
									Single* xSrc = xSrcStart;
									UInt64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Single> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Single> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Single> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Single> xDoubleColumn, IList<UInt64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Single* xSrcStart = &itemsX[startIndex])
						fixed (UInt64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Single* xSrc = xSrcStart;
							UInt64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Single xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Single, TY=System.Int16
		private class SingleInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Single> xColumn = xValues as IList<Single>;
				IList<Int16> yColumn = yValues as IList<Int16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Single> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int16>();

					Int16 min = yMath.MaxValue;
					Int16 max = yMath.MinValue;
					Int16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Single> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Single* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int16* ySrcStart = &yItems.Array[startIndex])
								{
									Single* xSrc = xSrcStart;
									Int16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Single> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Single> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Single> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Single> xDoubleColumn, IList<Int16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Single* xSrcStart = &itemsX[startIndex])
						fixed (Int16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Single* xSrc = xSrcStart;
							Int16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Single xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Single, TY=System.UInt16
		private class SingleUInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Single> xColumn = xValues as IList<Single>;
				IList<UInt16> yColumn = yValues as IList<UInt16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Single> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt16>();

					UInt16 min = yMath.MaxValue;
					UInt16 max = yMath.MinValue;
					UInt16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Single> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Single* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt16* ySrcStart = &yItems.Array[startIndex])
								{
									Single* xSrc = xSrcStart;
									UInt16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Single> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Single> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Single> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Single> xDoubleColumn, IList<UInt16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Single* xSrcStart = &itemsX[startIndex])
						fixed (UInt16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Single* xSrc = xSrcStart;
							UInt16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Single xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Single, TY=System.Byte
		private class SingleByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Single> xColumn = xValues as IList<Single>;
				IList<Byte> yColumn = yValues as IList<Byte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Single> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Byte>();

					Byte min = yMath.MaxValue;
					Byte max = yMath.MinValue;
					Byte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Single> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Byte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Single* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Byte* ySrcStart = &yItems.Array[startIndex])
								{
									Single* xSrc = xSrcStart;
									Byte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Single> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Single> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Single> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Single> xDoubleColumn, IList<Byte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Single* xSrcStart = &itemsX[startIndex])
						fixed (Byte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Single* xSrc = xSrcStart;
							Byte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Single xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Single, TY=System.SByte
		private class SingleSByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Single> xColumn = xValues as IList<Single>;
				IList<SByte> yColumn = yValues as IList<SByte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Single> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<SByte>();

					SByte min = yMath.MaxValue;
					SByte max = yMath.MinValue;
					SByte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Single> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<SByte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Single* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (SByte* ySrcStart = &yItems.Array[startIndex])
								{
									Single* xSrc = xSrcStart;
									SByte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Single> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Single> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Single> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Single> xDoubleColumn, IList<SByte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Single* xSrcStart = &itemsX[startIndex])
						fixed (SByte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Single* xSrc = xSrcStart;
							SByte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Single xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int32, TY=System.Double
		private class Int32DoubleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int32> xColumn = xValues as IList<Int32>;
				IList<Double> yColumn = yValues as IList<Double>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int32> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Double>();

					Double min = yMath.MaxValue;
					Double max = yMath.MinValue;
					Double current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Double> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Double* ySrcStart = &yItems.Array[startIndex])
								{
									Int32* xSrc = xSrcStart;
									Double* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int32> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int32> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int32> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int32> xDoubleColumn, IList<Double> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int32* xSrcStart = &itemsX[startIndex])
						fixed (Double* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int32* xSrc = xSrcStart;
							Double* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int32, TY=System.Single
		private class Int32SingleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int32> xColumn = xValues as IList<Int32>;
				IList<Single> yColumn = yValues as IList<Single>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int32> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Single>();

					Single min = yMath.MaxValue;
					Single max = yMath.MinValue;
					Single current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Single> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Single* ySrcStart = &yItems.Array[startIndex])
								{
									Int32* xSrc = xSrcStart;
									Single* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int32> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int32> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int32> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int32> xDoubleColumn, IList<Single> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int32* xSrcStart = &itemsX[startIndex])
						fixed (Single* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int32* xSrc = xSrcStart;
							Single* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int32, TY=System.Int32
		private class Int32Int32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int32> xColumn = xValues as IList<Int32>;
				IList<Int32> yColumn = yValues as IList<Int32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int32> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int32>();

					Int32 min = yMath.MaxValue;
					Int32 max = yMath.MinValue;
					Int32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int32* ySrcStart = &yItems.Array[startIndex])
								{
									Int32* xSrc = xSrcStart;
									Int32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int32> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int32> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int32> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int32> xDoubleColumn, IList<Int32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int32* xSrcStart = &itemsX[startIndex])
						fixed (Int32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int32* xSrc = xSrcStart;
							Int32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int32, TY=System.UInt32
		private class Int32UInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int32> xColumn = xValues as IList<Int32>;
				IList<UInt32> yColumn = yValues as IList<UInt32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int32> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt32>();

					UInt32 min = yMath.MaxValue;
					UInt32 max = yMath.MinValue;
					UInt32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt32* ySrcStart = &yItems.Array[startIndex])
								{
									Int32* xSrc = xSrcStart;
									UInt32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int32> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int32> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int32> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int32> xDoubleColumn, IList<UInt32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int32* xSrcStart = &itemsX[startIndex])
						fixed (UInt32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int32* xSrc = xSrcStart;
							UInt32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int32, TY=System.Int64
		private class Int32Int64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int32> xColumn = xValues as IList<Int32>;
				IList<Int64> yColumn = yValues as IList<Int64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int32> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int64>();

					Int64 min = yMath.MaxValue;
					Int64 max = yMath.MinValue;
					Int64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int64* ySrcStart = &yItems.Array[startIndex])
								{
									Int32* xSrc = xSrcStart;
									Int64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int32> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int32> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int32> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int32> xDoubleColumn, IList<Int64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int32* xSrcStart = &itemsX[startIndex])
						fixed (Int64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int32* xSrc = xSrcStart;
							Int64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int32, TY=System.UInt64
		private class Int32UInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int32> xColumn = xValues as IList<Int32>;
				IList<UInt64> yColumn = yValues as IList<UInt64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int32> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt64>();

					UInt64 min = yMath.MaxValue;
					UInt64 max = yMath.MinValue;
					UInt64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt64* ySrcStart = &yItems.Array[startIndex])
								{
									Int32* xSrc = xSrcStart;
									UInt64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int32> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int32> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int32> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int32> xDoubleColumn, IList<UInt64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int32* xSrcStart = &itemsX[startIndex])
						fixed (UInt64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int32* xSrc = xSrcStart;
							UInt64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int32, TY=System.Int16
		private class Int32Int16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int32> xColumn = xValues as IList<Int32>;
				IList<Int16> yColumn = yValues as IList<Int16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int32> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int16>();

					Int16 min = yMath.MaxValue;
					Int16 max = yMath.MinValue;
					Int16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int16* ySrcStart = &yItems.Array[startIndex])
								{
									Int32* xSrc = xSrcStart;
									Int16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int32> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int32> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int32> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int32> xDoubleColumn, IList<Int16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int32* xSrcStart = &itemsX[startIndex])
						fixed (Int16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int32* xSrc = xSrcStart;
							Int16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int32, TY=System.UInt16
		private class Int32UInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int32> xColumn = xValues as IList<Int32>;
				IList<UInt16> yColumn = yValues as IList<UInt16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int32> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt16>();

					UInt16 min = yMath.MaxValue;
					UInt16 max = yMath.MinValue;
					UInt16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt16* ySrcStart = &yItems.Array[startIndex])
								{
									Int32* xSrc = xSrcStart;
									UInt16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int32> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int32> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int32> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int32> xDoubleColumn, IList<UInt16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int32* xSrcStart = &itemsX[startIndex])
						fixed (UInt16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int32* xSrc = xSrcStart;
							UInt16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int32, TY=System.Byte
		private class Int32ByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int32> xColumn = xValues as IList<Int32>;
				IList<Byte> yColumn = yValues as IList<Byte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int32> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Byte>();

					Byte min = yMath.MaxValue;
					Byte max = yMath.MinValue;
					Byte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Byte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Byte* ySrcStart = &yItems.Array[startIndex])
								{
									Int32* xSrc = xSrcStart;
									Byte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int32> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int32> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int32> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int32> xDoubleColumn, IList<Byte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int32* xSrcStart = &itemsX[startIndex])
						fixed (Byte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int32* xSrc = xSrcStart;
							Byte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int32, TY=System.SByte
		private class Int32SByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int32> xColumn = xValues as IList<Int32>;
				IList<SByte> yColumn = yValues as IList<SByte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int32> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<SByte>();

					SByte min = yMath.MaxValue;
					SByte max = yMath.MinValue;
					SByte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<SByte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (SByte* ySrcStart = &yItems.Array[startIndex])
								{
									Int32* xSrc = xSrcStart;
									SByte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int32> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int32> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int32> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int32> xDoubleColumn, IList<SByte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int32* xSrcStart = &itemsX[startIndex])
						fixed (SByte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int32* xSrc = xSrcStart;
							SByte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt32, TY=System.Double
		private class UInt32DoubleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt32> xColumn = xValues as IList<UInt32>;
				IList<Double> yColumn = yValues as IList<Double>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt32> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Double>();

					Double min = yMath.MaxValue;
					Double max = yMath.MinValue;
					Double current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Double> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Double* ySrcStart = &yItems.Array[startIndex])
								{
									UInt32* xSrc = xSrcStart;
									Double* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt32> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt32> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt32> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt32> xDoubleColumn, IList<Double> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt32* xSrcStart = &itemsX[startIndex])
						fixed (Double* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt32* xSrc = xSrcStart;
							Double* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt32, TY=System.Single
		private class UInt32SingleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt32> xColumn = xValues as IList<UInt32>;
				IList<Single> yColumn = yValues as IList<Single>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt32> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Single>();

					Single min = yMath.MaxValue;
					Single max = yMath.MinValue;
					Single current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Single> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Single* ySrcStart = &yItems.Array[startIndex])
								{
									UInt32* xSrc = xSrcStart;
									Single* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt32> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt32> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt32> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt32> xDoubleColumn, IList<Single> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt32* xSrcStart = &itemsX[startIndex])
						fixed (Single* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt32* xSrc = xSrcStart;
							Single* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt32, TY=System.Int32
		private class UInt32Int32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt32> xColumn = xValues as IList<UInt32>;
				IList<Int32> yColumn = yValues as IList<Int32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt32> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int32>();

					Int32 min = yMath.MaxValue;
					Int32 max = yMath.MinValue;
					Int32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int32* ySrcStart = &yItems.Array[startIndex])
								{
									UInt32* xSrc = xSrcStart;
									Int32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt32> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt32> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt32> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt32> xDoubleColumn, IList<Int32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt32* xSrcStart = &itemsX[startIndex])
						fixed (Int32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt32* xSrc = xSrcStart;
							Int32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt32, TY=System.UInt32
		private class UInt32UInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt32> xColumn = xValues as IList<UInt32>;
				IList<UInt32> yColumn = yValues as IList<UInt32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt32> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt32>();

					UInt32 min = yMath.MaxValue;
					UInt32 max = yMath.MinValue;
					UInt32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt32* ySrcStart = &yItems.Array[startIndex])
								{
									UInt32* xSrc = xSrcStart;
									UInt32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt32> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt32> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt32> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt32> xDoubleColumn, IList<UInt32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt32* xSrcStart = &itemsX[startIndex])
						fixed (UInt32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt32* xSrc = xSrcStart;
							UInt32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt32, TY=System.Int64
		private class UInt32Int64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt32> xColumn = xValues as IList<UInt32>;
				IList<Int64> yColumn = yValues as IList<Int64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt32> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int64>();

					Int64 min = yMath.MaxValue;
					Int64 max = yMath.MinValue;
					Int64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int64* ySrcStart = &yItems.Array[startIndex])
								{
									UInt32* xSrc = xSrcStart;
									Int64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt32> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt32> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt32> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt32> xDoubleColumn, IList<Int64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt32* xSrcStart = &itemsX[startIndex])
						fixed (Int64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt32* xSrc = xSrcStart;
							Int64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt32, TY=System.UInt64
		private class UInt32UInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt32> xColumn = xValues as IList<UInt32>;
				IList<UInt64> yColumn = yValues as IList<UInt64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt32> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt64>();

					UInt64 min = yMath.MaxValue;
					UInt64 max = yMath.MinValue;
					UInt64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt64* ySrcStart = &yItems.Array[startIndex])
								{
									UInt32* xSrc = xSrcStart;
									UInt64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt32> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt32> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt32> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt32> xDoubleColumn, IList<UInt64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt32* xSrcStart = &itemsX[startIndex])
						fixed (UInt64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt32* xSrc = xSrcStart;
							UInt64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt32, TY=System.Int16
		private class UInt32Int16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt32> xColumn = xValues as IList<UInt32>;
				IList<Int16> yColumn = yValues as IList<Int16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt32> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int16>();

					Int16 min = yMath.MaxValue;
					Int16 max = yMath.MinValue;
					Int16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int16* ySrcStart = &yItems.Array[startIndex])
								{
									UInt32* xSrc = xSrcStart;
									Int16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt32> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt32> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt32> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt32> xDoubleColumn, IList<Int16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt32* xSrcStart = &itemsX[startIndex])
						fixed (Int16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt32* xSrc = xSrcStart;
							Int16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt32, TY=System.UInt16
		private class UInt32UInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt32> xColumn = xValues as IList<UInt32>;
				IList<UInt16> yColumn = yValues as IList<UInt16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt32> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt16>();

					UInt16 min = yMath.MaxValue;
					UInt16 max = yMath.MinValue;
					UInt16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt16* ySrcStart = &yItems.Array[startIndex])
								{
									UInt32* xSrc = xSrcStart;
									UInt16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt32> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt32> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt32> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt32> xDoubleColumn, IList<UInt16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt32* xSrcStart = &itemsX[startIndex])
						fixed (UInt16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt32* xSrc = xSrcStart;
							UInt16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt32, TY=System.Byte
		private class UInt32ByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt32> xColumn = xValues as IList<UInt32>;
				IList<Byte> yColumn = yValues as IList<Byte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt32> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Byte>();

					Byte min = yMath.MaxValue;
					Byte max = yMath.MinValue;
					Byte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Byte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Byte* ySrcStart = &yItems.Array[startIndex])
								{
									UInt32* xSrc = xSrcStart;
									Byte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt32> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt32> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt32> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt32> xDoubleColumn, IList<Byte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt32* xSrcStart = &itemsX[startIndex])
						fixed (Byte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt32* xSrc = xSrcStart;
							Byte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt32, TY=System.SByte
		private class UInt32SByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt32> xColumn = xValues as IList<UInt32>;
				IList<SByte> yColumn = yValues as IList<SByte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt32> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<SByte>();

					SByte min = yMath.MaxValue;
					SByte max = yMath.MinValue;
					SByte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt32> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<SByte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt32* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (SByte* ySrcStart = &yItems.Array[startIndex])
								{
									UInt32* xSrc = xSrcStart;
									SByte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt32> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt32> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt32> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt32> xDoubleColumn, IList<SByte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt32* xSrcStart = &itemsX[startIndex])
						fixed (SByte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt32* xSrc = xSrcStart;
							SByte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt32 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int64, TY=System.Double
		private class Int64DoubleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int64> xColumn = xValues as IList<Int64>;
				IList<Double> yColumn = yValues as IList<Double>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int64> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Double>();

					Double min = yMath.MaxValue;
					Double max = yMath.MinValue;
					Double current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Double> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Double* ySrcStart = &yItems.Array[startIndex])
								{
									Int64* xSrc = xSrcStart;
									Double* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int64> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int64> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int64> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int64> xDoubleColumn, IList<Double> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int64* xSrcStart = &itemsX[startIndex])
						fixed (Double* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int64* xSrc = xSrcStart;
							Double* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int64, TY=System.Single
		private class Int64SingleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int64> xColumn = xValues as IList<Int64>;
				IList<Single> yColumn = yValues as IList<Single>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int64> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Single>();

					Single min = yMath.MaxValue;
					Single max = yMath.MinValue;
					Single current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Single> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Single* ySrcStart = &yItems.Array[startIndex])
								{
									Int64* xSrc = xSrcStart;
									Single* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int64> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int64> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int64> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int64> xDoubleColumn, IList<Single> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int64* xSrcStart = &itemsX[startIndex])
						fixed (Single* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int64* xSrc = xSrcStart;
							Single* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int64, TY=System.Int32
		private class Int64Int32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int64> xColumn = xValues as IList<Int64>;
				IList<Int32> yColumn = yValues as IList<Int32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int64> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int32>();

					Int32 min = yMath.MaxValue;
					Int32 max = yMath.MinValue;
					Int32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int32* ySrcStart = &yItems.Array[startIndex])
								{
									Int64* xSrc = xSrcStart;
									Int32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int64> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int64> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int64> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int64> xDoubleColumn, IList<Int32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int64* xSrcStart = &itemsX[startIndex])
						fixed (Int32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int64* xSrc = xSrcStart;
							Int32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int64, TY=System.UInt32
		private class Int64UInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int64> xColumn = xValues as IList<Int64>;
				IList<UInt32> yColumn = yValues as IList<UInt32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int64> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt32>();

					UInt32 min = yMath.MaxValue;
					UInt32 max = yMath.MinValue;
					UInt32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt32* ySrcStart = &yItems.Array[startIndex])
								{
									Int64* xSrc = xSrcStart;
									UInt32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int64> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int64> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int64> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int64> xDoubleColumn, IList<UInt32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int64* xSrcStart = &itemsX[startIndex])
						fixed (UInt32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int64* xSrc = xSrcStart;
							UInt32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int64, TY=System.Int64
		private class Int64Int64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int64> xColumn = xValues as IList<Int64>;
				IList<Int64> yColumn = yValues as IList<Int64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int64> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int64>();

					Int64 min = yMath.MaxValue;
					Int64 max = yMath.MinValue;
					Int64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int64* ySrcStart = &yItems.Array[startIndex])
								{
									Int64* xSrc = xSrcStart;
									Int64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int64> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int64> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int64> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int64> xDoubleColumn, IList<Int64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int64* xSrcStart = &itemsX[startIndex])
						fixed (Int64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int64* xSrc = xSrcStart;
							Int64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int64, TY=System.UInt64
		private class Int64UInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int64> xColumn = xValues as IList<Int64>;
				IList<UInt64> yColumn = yValues as IList<UInt64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int64> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt64>();

					UInt64 min = yMath.MaxValue;
					UInt64 max = yMath.MinValue;
					UInt64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt64* ySrcStart = &yItems.Array[startIndex])
								{
									Int64* xSrc = xSrcStart;
									UInt64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int64> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int64> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int64> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int64> xDoubleColumn, IList<UInt64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int64* xSrcStart = &itemsX[startIndex])
						fixed (UInt64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int64* xSrc = xSrcStart;
							UInt64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int64, TY=System.Int16
		private class Int64Int16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int64> xColumn = xValues as IList<Int64>;
				IList<Int16> yColumn = yValues as IList<Int16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int64> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int16>();

					Int16 min = yMath.MaxValue;
					Int16 max = yMath.MinValue;
					Int16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int16* ySrcStart = &yItems.Array[startIndex])
								{
									Int64* xSrc = xSrcStart;
									Int16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int64> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int64> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int64> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int64> xDoubleColumn, IList<Int16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int64* xSrcStart = &itemsX[startIndex])
						fixed (Int16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int64* xSrc = xSrcStart;
							Int16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int64, TY=System.UInt16
		private class Int64UInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int64> xColumn = xValues as IList<Int64>;
				IList<UInt16> yColumn = yValues as IList<UInt16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int64> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt16>();

					UInt16 min = yMath.MaxValue;
					UInt16 max = yMath.MinValue;
					UInt16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt16* ySrcStart = &yItems.Array[startIndex])
								{
									Int64* xSrc = xSrcStart;
									UInt16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int64> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int64> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int64> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int64> xDoubleColumn, IList<UInt16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int64* xSrcStart = &itemsX[startIndex])
						fixed (UInt16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int64* xSrc = xSrcStart;
							UInt16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int64, TY=System.Byte
		private class Int64ByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int64> xColumn = xValues as IList<Int64>;
				IList<Byte> yColumn = yValues as IList<Byte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int64> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Byte>();

					Byte min = yMath.MaxValue;
					Byte max = yMath.MinValue;
					Byte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Byte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Byte* ySrcStart = &yItems.Array[startIndex])
								{
									Int64* xSrc = xSrcStart;
									Byte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int64> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int64> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int64> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int64> xDoubleColumn, IList<Byte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int64* xSrcStart = &itemsX[startIndex])
						fixed (Byte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int64* xSrc = xSrcStart;
							Byte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int64, TY=System.SByte
		private class Int64SByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int64> xColumn = xValues as IList<Int64>;
				IList<SByte> yColumn = yValues as IList<SByte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int64> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<SByte>();

					SByte min = yMath.MaxValue;
					SByte max = yMath.MinValue;
					SByte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<SByte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (SByte* ySrcStart = &yItems.Array[startIndex])
								{
									Int64* xSrc = xSrcStart;
									SByte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int64> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int64> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int64> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int64> xDoubleColumn, IList<SByte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int64* xSrcStart = &itemsX[startIndex])
						fixed (SByte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int64* xSrc = xSrcStart;
							SByte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt64, TY=System.Double
		private class UInt64DoubleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt64> xColumn = xValues as IList<UInt64>;
				IList<Double> yColumn = yValues as IList<Double>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt64> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Double>();

					Double min = yMath.MaxValue;
					Double max = yMath.MinValue;
					Double current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Double> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Double* ySrcStart = &yItems.Array[startIndex])
								{
									UInt64* xSrc = xSrcStart;
									Double* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt64> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt64> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt64> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt64> xDoubleColumn, IList<Double> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt64* xSrcStart = &itemsX[startIndex])
						fixed (Double* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt64* xSrc = xSrcStart;
							Double* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt64, TY=System.Single
		private class UInt64SingleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt64> xColumn = xValues as IList<UInt64>;
				IList<Single> yColumn = yValues as IList<Single>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt64> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Single>();

					Single min = yMath.MaxValue;
					Single max = yMath.MinValue;
					Single current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Single> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Single* ySrcStart = &yItems.Array[startIndex])
								{
									UInt64* xSrc = xSrcStart;
									Single* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt64> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt64> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt64> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt64> xDoubleColumn, IList<Single> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt64* xSrcStart = &itemsX[startIndex])
						fixed (Single* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt64* xSrc = xSrcStart;
							Single* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt64, TY=System.Int32
		private class UInt64Int32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt64> xColumn = xValues as IList<UInt64>;
				IList<Int32> yColumn = yValues as IList<Int32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt64> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int32>();

					Int32 min = yMath.MaxValue;
					Int32 max = yMath.MinValue;
					Int32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int32* ySrcStart = &yItems.Array[startIndex])
								{
									UInt64* xSrc = xSrcStart;
									Int32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt64> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt64> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt64> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt64> xDoubleColumn, IList<Int32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt64* xSrcStart = &itemsX[startIndex])
						fixed (Int32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt64* xSrc = xSrcStart;
							Int32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt64, TY=System.UInt32
		private class UInt64UInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt64> xColumn = xValues as IList<UInt64>;
				IList<UInt32> yColumn = yValues as IList<UInt32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt64> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt32>();

					UInt32 min = yMath.MaxValue;
					UInt32 max = yMath.MinValue;
					UInt32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt32* ySrcStart = &yItems.Array[startIndex])
								{
									UInt64* xSrc = xSrcStart;
									UInt32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt64> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt64> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt64> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt64> xDoubleColumn, IList<UInt32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt64* xSrcStart = &itemsX[startIndex])
						fixed (UInt32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt64* xSrc = xSrcStart;
							UInt32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt64, TY=System.Int64
		private class UInt64Int64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt64> xColumn = xValues as IList<UInt64>;
				IList<Int64> yColumn = yValues as IList<Int64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt64> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int64>();

					Int64 min = yMath.MaxValue;
					Int64 max = yMath.MinValue;
					Int64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int64* ySrcStart = &yItems.Array[startIndex])
								{
									UInt64* xSrc = xSrcStart;
									Int64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt64> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt64> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt64> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt64> xDoubleColumn, IList<Int64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt64* xSrcStart = &itemsX[startIndex])
						fixed (Int64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt64* xSrc = xSrcStart;
							Int64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt64, TY=System.UInt64
		private class UInt64UInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt64> xColumn = xValues as IList<UInt64>;
				IList<UInt64> yColumn = yValues as IList<UInt64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt64> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt64>();

					UInt64 min = yMath.MaxValue;
					UInt64 max = yMath.MinValue;
					UInt64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt64* ySrcStart = &yItems.Array[startIndex])
								{
									UInt64* xSrc = xSrcStart;
									UInt64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt64> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt64> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt64> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt64> xDoubleColumn, IList<UInt64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt64* xSrcStart = &itemsX[startIndex])
						fixed (UInt64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt64* xSrc = xSrcStart;
							UInt64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt64, TY=System.Int16
		private class UInt64Int16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt64> xColumn = xValues as IList<UInt64>;
				IList<Int16> yColumn = yValues as IList<Int16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt64> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int16>();

					Int16 min = yMath.MaxValue;
					Int16 max = yMath.MinValue;
					Int16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int16* ySrcStart = &yItems.Array[startIndex])
								{
									UInt64* xSrc = xSrcStart;
									Int16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt64> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt64> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt64> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt64> xDoubleColumn, IList<Int16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt64* xSrcStart = &itemsX[startIndex])
						fixed (Int16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt64* xSrc = xSrcStart;
							Int16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt64, TY=System.UInt16
		private class UInt64UInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt64> xColumn = xValues as IList<UInt64>;
				IList<UInt16> yColumn = yValues as IList<UInt16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt64> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt16>();

					UInt16 min = yMath.MaxValue;
					UInt16 max = yMath.MinValue;
					UInt16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt16* ySrcStart = &yItems.Array[startIndex])
								{
									UInt64* xSrc = xSrcStart;
									UInt16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt64> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt64> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt64> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt64> xDoubleColumn, IList<UInt16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt64* xSrcStart = &itemsX[startIndex])
						fixed (UInt16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt64* xSrc = xSrcStart;
							UInt16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt64, TY=System.Byte
		private class UInt64ByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt64> xColumn = xValues as IList<UInt64>;
				IList<Byte> yColumn = yValues as IList<Byte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt64> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Byte>();

					Byte min = yMath.MaxValue;
					Byte max = yMath.MinValue;
					Byte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Byte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Byte* ySrcStart = &yItems.Array[startIndex])
								{
									UInt64* xSrc = xSrcStart;
									Byte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt64> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt64> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt64> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt64> xDoubleColumn, IList<Byte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt64* xSrcStart = &itemsX[startIndex])
						fixed (Byte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt64* xSrc = xSrcStart;
							Byte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt64, TY=System.SByte
		private class UInt64SByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt64> xColumn = xValues as IList<UInt64>;
				IList<SByte> yColumn = yValues as IList<SByte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt64> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<SByte>();

					SByte min = yMath.MaxValue;
					SByte max = yMath.MinValue;
					SByte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt64> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<SByte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt64* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (SByte* ySrcStart = &yItems.Array[startIndex])
								{
									UInt64* xSrc = xSrcStart;
									SByte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt64> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt64> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt64> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt64> xDoubleColumn, IList<SByte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt64* xSrcStart = &itemsX[startIndex])
						fixed (SByte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt64* xSrc = xSrcStart;
							SByte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt64 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int16, TY=System.Double
		private class Int16DoubleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int16> xColumn = xValues as IList<Int16>;
				IList<Double> yColumn = yValues as IList<Double>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int16> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Double>();

					Double min = yMath.MaxValue;
					Double max = yMath.MinValue;
					Double current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Double> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Double* ySrcStart = &yItems.Array[startIndex])
								{
									Int16* xSrc = xSrcStart;
									Double* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int16> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int16> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int16> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int16> xDoubleColumn, IList<Double> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int16* xSrcStart = &itemsX[startIndex])
						fixed (Double* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int16* xSrc = xSrcStart;
							Double* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int16, TY=System.Single
		private class Int16SingleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int16> xColumn = xValues as IList<Int16>;
				IList<Single> yColumn = yValues as IList<Single>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int16> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Single>();

					Single min = yMath.MaxValue;
					Single max = yMath.MinValue;
					Single current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Single> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Single* ySrcStart = &yItems.Array[startIndex])
								{
									Int16* xSrc = xSrcStart;
									Single* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int16> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int16> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int16> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int16> xDoubleColumn, IList<Single> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int16* xSrcStart = &itemsX[startIndex])
						fixed (Single* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int16* xSrc = xSrcStart;
							Single* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int16, TY=System.Int32
		private class Int16Int32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int16> xColumn = xValues as IList<Int16>;
				IList<Int32> yColumn = yValues as IList<Int32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int16> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int32>();

					Int32 min = yMath.MaxValue;
					Int32 max = yMath.MinValue;
					Int32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int32* ySrcStart = &yItems.Array[startIndex])
								{
									Int16* xSrc = xSrcStart;
									Int32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int16> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int16> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int16> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int16> xDoubleColumn, IList<Int32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int16* xSrcStart = &itemsX[startIndex])
						fixed (Int32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int16* xSrc = xSrcStart;
							Int32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int16, TY=System.UInt32
		private class Int16UInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int16> xColumn = xValues as IList<Int16>;
				IList<UInt32> yColumn = yValues as IList<UInt32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int16> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt32>();

					UInt32 min = yMath.MaxValue;
					UInt32 max = yMath.MinValue;
					UInt32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt32* ySrcStart = &yItems.Array[startIndex])
								{
									Int16* xSrc = xSrcStart;
									UInt32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int16> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int16> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int16> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int16> xDoubleColumn, IList<UInt32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int16* xSrcStart = &itemsX[startIndex])
						fixed (UInt32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int16* xSrc = xSrcStart;
							UInt32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int16, TY=System.Int64
		private class Int16Int64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int16> xColumn = xValues as IList<Int16>;
				IList<Int64> yColumn = yValues as IList<Int64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int16> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int64>();

					Int64 min = yMath.MaxValue;
					Int64 max = yMath.MinValue;
					Int64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int64* ySrcStart = &yItems.Array[startIndex])
								{
									Int16* xSrc = xSrcStart;
									Int64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int16> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int16> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int16> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int16> xDoubleColumn, IList<Int64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int16* xSrcStart = &itemsX[startIndex])
						fixed (Int64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int16* xSrc = xSrcStart;
							Int64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int16, TY=System.UInt64
		private class Int16UInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int16> xColumn = xValues as IList<Int16>;
				IList<UInt64> yColumn = yValues as IList<UInt64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int16> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt64>();

					UInt64 min = yMath.MaxValue;
					UInt64 max = yMath.MinValue;
					UInt64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt64* ySrcStart = &yItems.Array[startIndex])
								{
									Int16* xSrc = xSrcStart;
									UInt64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int16> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int16> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int16> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int16> xDoubleColumn, IList<UInt64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int16* xSrcStart = &itemsX[startIndex])
						fixed (UInt64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int16* xSrc = xSrcStart;
							UInt64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int16, TY=System.Int16
		private class Int16Int16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int16> xColumn = xValues as IList<Int16>;
				IList<Int16> yColumn = yValues as IList<Int16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int16> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int16>();

					Int16 min = yMath.MaxValue;
					Int16 max = yMath.MinValue;
					Int16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int16* ySrcStart = &yItems.Array[startIndex])
								{
									Int16* xSrc = xSrcStart;
									Int16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int16> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int16> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int16> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int16> xDoubleColumn, IList<Int16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int16* xSrcStart = &itemsX[startIndex])
						fixed (Int16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int16* xSrc = xSrcStart;
							Int16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int16, TY=System.UInt16
		private class Int16UInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int16> xColumn = xValues as IList<Int16>;
				IList<UInt16> yColumn = yValues as IList<UInt16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int16> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt16>();

					UInt16 min = yMath.MaxValue;
					UInt16 max = yMath.MinValue;
					UInt16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt16* ySrcStart = &yItems.Array[startIndex])
								{
									Int16* xSrc = xSrcStart;
									UInt16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int16> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int16> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int16> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int16> xDoubleColumn, IList<UInt16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int16* xSrcStart = &itemsX[startIndex])
						fixed (UInt16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int16* xSrc = xSrcStart;
							UInt16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int16, TY=System.Byte
		private class Int16ByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int16> xColumn = xValues as IList<Int16>;
				IList<Byte> yColumn = yValues as IList<Byte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int16> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Byte>();

					Byte min = yMath.MaxValue;
					Byte max = yMath.MinValue;
					Byte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Byte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Byte* ySrcStart = &yItems.Array[startIndex])
								{
									Int16* xSrc = xSrcStart;
									Byte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int16> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int16> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int16> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int16> xDoubleColumn, IList<Byte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int16* xSrcStart = &itemsX[startIndex])
						fixed (Byte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int16* xSrc = xSrcStart;
							Byte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Int16, TY=System.SByte
		private class Int16SByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Int16> xColumn = xValues as IList<Int16>;
				IList<SByte> yColumn = yValues as IList<SByte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Int16> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<SByte>();

					SByte min = yMath.MaxValue;
					SByte max = yMath.MinValue;
					SByte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Int16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<SByte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Int16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (SByte* ySrcStart = &yItems.Array[startIndex])
								{
									Int16* xSrc = xSrcStart;
									SByte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Int16> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Int16> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Int16> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Int16> xDoubleColumn, IList<SByte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Int16* xSrcStart = &itemsX[startIndex])
						fixed (SByte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Int16* xSrc = xSrcStart;
							SByte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Int16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt16, TY=System.Double
		private class UInt16DoubleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt16> xColumn = xValues as IList<UInt16>;
				IList<Double> yColumn = yValues as IList<Double>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt16> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Double>();

					Double min = yMath.MaxValue;
					Double max = yMath.MinValue;
					Double current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Double> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Double* ySrcStart = &yItems.Array[startIndex])
								{
									UInt16* xSrc = xSrcStart;
									Double* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt16> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt16> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt16> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt16> xDoubleColumn, IList<Double> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt16* xSrcStart = &itemsX[startIndex])
						fixed (Double* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt16* xSrc = xSrcStart;
							Double* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt16, TY=System.Single
		private class UInt16SingleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt16> xColumn = xValues as IList<UInt16>;
				IList<Single> yColumn = yValues as IList<Single>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt16> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Single>();

					Single min = yMath.MaxValue;
					Single max = yMath.MinValue;
					Single current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Single> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Single* ySrcStart = &yItems.Array[startIndex])
								{
									UInt16* xSrc = xSrcStart;
									Single* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt16> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt16> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt16> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt16> xDoubleColumn, IList<Single> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt16* xSrcStart = &itemsX[startIndex])
						fixed (Single* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt16* xSrc = xSrcStart;
							Single* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt16, TY=System.Int32
		private class UInt16Int32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt16> xColumn = xValues as IList<UInt16>;
				IList<Int32> yColumn = yValues as IList<Int32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt16> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int32>();

					Int32 min = yMath.MaxValue;
					Int32 max = yMath.MinValue;
					Int32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int32* ySrcStart = &yItems.Array[startIndex])
								{
									UInt16* xSrc = xSrcStart;
									Int32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt16> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt16> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt16> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt16> xDoubleColumn, IList<Int32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt16* xSrcStart = &itemsX[startIndex])
						fixed (Int32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt16* xSrc = xSrcStart;
							Int32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt16, TY=System.UInt32
		private class UInt16UInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt16> xColumn = xValues as IList<UInt16>;
				IList<UInt32> yColumn = yValues as IList<UInt32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt16> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt32>();

					UInt32 min = yMath.MaxValue;
					UInt32 max = yMath.MinValue;
					UInt32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt32* ySrcStart = &yItems.Array[startIndex])
								{
									UInt16* xSrc = xSrcStart;
									UInt32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt16> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt16> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt16> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt16> xDoubleColumn, IList<UInt32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt16* xSrcStart = &itemsX[startIndex])
						fixed (UInt32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt16* xSrc = xSrcStart;
							UInt32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt16, TY=System.Int64
		private class UInt16Int64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt16> xColumn = xValues as IList<UInt16>;
				IList<Int64> yColumn = yValues as IList<Int64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt16> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int64>();

					Int64 min = yMath.MaxValue;
					Int64 max = yMath.MinValue;
					Int64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int64* ySrcStart = &yItems.Array[startIndex])
								{
									UInt16* xSrc = xSrcStart;
									Int64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt16> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt16> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt16> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt16> xDoubleColumn, IList<Int64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt16* xSrcStart = &itemsX[startIndex])
						fixed (Int64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt16* xSrc = xSrcStart;
							Int64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt16, TY=System.UInt64
		private class UInt16UInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt16> xColumn = xValues as IList<UInt16>;
				IList<UInt64> yColumn = yValues as IList<UInt64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt16> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt64>();

					UInt64 min = yMath.MaxValue;
					UInt64 max = yMath.MinValue;
					UInt64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt64* ySrcStart = &yItems.Array[startIndex])
								{
									UInt16* xSrc = xSrcStart;
									UInt64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt16> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt16> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt16> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt16> xDoubleColumn, IList<UInt64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt16* xSrcStart = &itemsX[startIndex])
						fixed (UInt64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt16* xSrc = xSrcStart;
							UInt64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt16, TY=System.Int16
		private class UInt16Int16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt16> xColumn = xValues as IList<UInt16>;
				IList<Int16> yColumn = yValues as IList<Int16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt16> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int16>();

					Int16 min = yMath.MaxValue;
					Int16 max = yMath.MinValue;
					Int16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int16* ySrcStart = &yItems.Array[startIndex])
								{
									UInt16* xSrc = xSrcStart;
									Int16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt16> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt16> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt16> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt16> xDoubleColumn, IList<Int16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt16* xSrcStart = &itemsX[startIndex])
						fixed (Int16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt16* xSrc = xSrcStart;
							Int16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt16, TY=System.UInt16
		private class UInt16UInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt16> xColumn = xValues as IList<UInt16>;
				IList<UInt16> yColumn = yValues as IList<UInt16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt16> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt16>();

					UInt16 min = yMath.MaxValue;
					UInt16 max = yMath.MinValue;
					UInt16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt16* ySrcStart = &yItems.Array[startIndex])
								{
									UInt16* xSrc = xSrcStart;
									UInt16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt16> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt16> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt16> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt16> xDoubleColumn, IList<UInt16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt16* xSrcStart = &itemsX[startIndex])
						fixed (UInt16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt16* xSrc = xSrcStart;
							UInt16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt16, TY=System.Byte
		private class UInt16ByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt16> xColumn = xValues as IList<UInt16>;
				IList<Byte> yColumn = yValues as IList<Byte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt16> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Byte>();

					Byte min = yMath.MaxValue;
					Byte max = yMath.MinValue;
					Byte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Byte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Byte* ySrcStart = &yItems.Array[startIndex])
								{
									UInt16* xSrc = xSrcStart;
									Byte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt16> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt16> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt16> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt16> xDoubleColumn, IList<Byte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt16* xSrcStart = &itemsX[startIndex])
						fixed (Byte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt16* xSrc = xSrcStart;
							Byte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.UInt16, TY=System.SByte
		private class UInt16SByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<UInt16> xColumn = xValues as IList<UInt16>;
				IList<SByte> yColumn = yValues as IList<SByte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<UInt16> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<SByte>();

					SByte min = yMath.MaxValue;
					SByte max = yMath.MinValue;
					SByte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<UInt16> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<SByte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (UInt16* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (SByte* ySrcStart = &yItems.Array[startIndex])
								{
									UInt16* xSrc = xSrcStart;
									SByte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<UInt16> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<UInt16> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<UInt16> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<UInt16> xDoubleColumn, IList<SByte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (UInt16* xSrcStart = &itemsX[startIndex])
						fixed (SByte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							UInt16* xSrc = xSrcStart;
							SByte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(UInt16 xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Byte, TY=System.Double
		private class ByteDoubleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Byte> xColumn = xValues as IList<Byte>;
				IList<Double> yColumn = yValues as IList<Double>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Byte> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Double>();

					Double min = yMath.MaxValue;
					Double max = yMath.MinValue;
					Double current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Byte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Double> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Byte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Double* ySrcStart = &yItems.Array[startIndex])
								{
									Byte* xSrc = xSrcStart;
									Double* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Byte> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Byte> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Byte> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Byte> xDoubleColumn, IList<Double> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Byte* xSrcStart = &itemsX[startIndex])
						fixed (Double* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Byte* xSrc = xSrcStart;
							Double* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Byte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Byte, TY=System.Single
		private class ByteSingleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Byte> xColumn = xValues as IList<Byte>;
				IList<Single> yColumn = yValues as IList<Single>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Byte> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Single>();

					Single min = yMath.MaxValue;
					Single max = yMath.MinValue;
					Single current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Byte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Single> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Byte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Single* ySrcStart = &yItems.Array[startIndex])
								{
									Byte* xSrc = xSrcStart;
									Single* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Byte> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Byte> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Byte> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Byte> xDoubleColumn, IList<Single> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Byte* xSrcStart = &itemsX[startIndex])
						fixed (Single* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Byte* xSrc = xSrcStart;
							Single* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Byte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Byte, TY=System.Int32
		private class ByteInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Byte> xColumn = xValues as IList<Byte>;
				IList<Int32> yColumn = yValues as IList<Int32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Byte> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int32>();

					Int32 min = yMath.MaxValue;
					Int32 max = yMath.MinValue;
					Int32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Byte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Byte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int32* ySrcStart = &yItems.Array[startIndex])
								{
									Byte* xSrc = xSrcStart;
									Int32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Byte> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Byte> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Byte> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Byte> xDoubleColumn, IList<Int32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Byte* xSrcStart = &itemsX[startIndex])
						fixed (Int32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Byte* xSrc = xSrcStart;
							Int32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Byte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Byte, TY=System.UInt32
		private class ByteUInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Byte> xColumn = xValues as IList<Byte>;
				IList<UInt32> yColumn = yValues as IList<UInt32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Byte> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt32>();

					UInt32 min = yMath.MaxValue;
					UInt32 max = yMath.MinValue;
					UInt32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Byte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Byte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt32* ySrcStart = &yItems.Array[startIndex])
								{
									Byte* xSrc = xSrcStart;
									UInt32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Byte> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Byte> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Byte> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Byte> xDoubleColumn, IList<UInt32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Byte* xSrcStart = &itemsX[startIndex])
						fixed (UInt32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Byte* xSrc = xSrcStart;
							UInt32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Byte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Byte, TY=System.Int64
		private class ByteInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Byte> xColumn = xValues as IList<Byte>;
				IList<Int64> yColumn = yValues as IList<Int64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Byte> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int64>();

					Int64 min = yMath.MaxValue;
					Int64 max = yMath.MinValue;
					Int64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Byte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Byte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int64* ySrcStart = &yItems.Array[startIndex])
								{
									Byte* xSrc = xSrcStart;
									Int64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Byte> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Byte> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Byte> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Byte> xDoubleColumn, IList<Int64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Byte* xSrcStart = &itemsX[startIndex])
						fixed (Int64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Byte* xSrc = xSrcStart;
							Int64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Byte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Byte, TY=System.UInt64
		private class ByteUInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Byte> xColumn = xValues as IList<Byte>;
				IList<UInt64> yColumn = yValues as IList<UInt64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Byte> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt64>();

					UInt64 min = yMath.MaxValue;
					UInt64 max = yMath.MinValue;
					UInt64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Byte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Byte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt64* ySrcStart = &yItems.Array[startIndex])
								{
									Byte* xSrc = xSrcStart;
									UInt64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Byte> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Byte> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Byte> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Byte> xDoubleColumn, IList<UInt64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Byte* xSrcStart = &itemsX[startIndex])
						fixed (UInt64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Byte* xSrc = xSrcStart;
							UInt64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Byte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Byte, TY=System.Int16
		private class ByteInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Byte> xColumn = xValues as IList<Byte>;
				IList<Int16> yColumn = yValues as IList<Int16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Byte> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int16>();

					Int16 min = yMath.MaxValue;
					Int16 max = yMath.MinValue;
					Int16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Byte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Byte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int16* ySrcStart = &yItems.Array[startIndex])
								{
									Byte* xSrc = xSrcStart;
									Int16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Byte> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Byte> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Byte> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Byte> xDoubleColumn, IList<Int16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Byte* xSrcStart = &itemsX[startIndex])
						fixed (Int16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Byte* xSrc = xSrcStart;
							Int16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Byte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Byte, TY=System.UInt16
		private class ByteUInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Byte> xColumn = xValues as IList<Byte>;
				IList<UInt16> yColumn = yValues as IList<UInt16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Byte> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt16>();

					UInt16 min = yMath.MaxValue;
					UInt16 max = yMath.MinValue;
					UInt16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Byte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Byte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt16* ySrcStart = &yItems.Array[startIndex])
								{
									Byte* xSrc = xSrcStart;
									UInt16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Byte> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Byte> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Byte> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Byte> xDoubleColumn, IList<UInt16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Byte* xSrcStart = &itemsX[startIndex])
						fixed (UInt16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Byte* xSrc = xSrcStart;
							UInt16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Byte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Byte, TY=System.Byte
		private class ByteByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Byte> xColumn = xValues as IList<Byte>;
				IList<Byte> yColumn = yValues as IList<Byte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Byte> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Byte>();

					Byte min = yMath.MaxValue;
					Byte max = yMath.MinValue;
					Byte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Byte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Byte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Byte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Byte* ySrcStart = &yItems.Array[startIndex])
								{
									Byte* xSrc = xSrcStart;
									Byte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Byte> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Byte> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Byte> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Byte> xDoubleColumn, IList<Byte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Byte* xSrcStart = &itemsX[startIndex])
						fixed (Byte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Byte* xSrc = xSrcStart;
							Byte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Byte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.Byte, TY=System.SByte
		private class ByteSByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<Byte> xColumn = xValues as IList<Byte>;
				IList<SByte> yColumn = yValues as IList<SByte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<Byte> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<SByte>();

					SByte min = yMath.MaxValue;
					SByte max = yMath.MinValue;
					SByte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<Byte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<SByte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (Byte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (SByte* ySrcStart = &yItems.Array[startIndex])
								{
									Byte* xSrc = xSrcStart;
									SByte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<Byte> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<Byte> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<Byte> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<Byte> xDoubleColumn, IList<SByte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (Byte* xSrcStart = &itemsX[startIndex])
						fixed (SByte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							Byte* xSrc = xSrcStart;
							SByte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(Byte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.SByte, TY=System.Double
		private class SByteDoubleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<SByte> xColumn = xValues as IList<SByte>;
				IList<Double> yColumn = yValues as IList<Double>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<SByte> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Double>();

					Double min = yMath.MaxValue;
					Double max = yMath.MinValue;
					Double current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<SByte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Double> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (SByte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Double* ySrcStart = &yItems.Array[startIndex])
								{
									SByte* xSrc = xSrcStart;
									Double* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<SByte> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<SByte> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<SByte> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<SByte> xDoubleColumn, IList<Double> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (SByte* xSrcStart = &itemsX[startIndex])
						fixed (Double* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							SByte* xSrc = xSrcStart;
							Double* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(SByte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.SByte, TY=System.Single
		private class SByteSingleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<SByte> xColumn = xValues as IList<SByte>;
				IList<Single> yColumn = yValues as IList<Single>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<SByte> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Single>();

					Single min = yMath.MaxValue;
					Single max = yMath.MinValue;
					Single current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<SByte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Single> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (SByte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Single* ySrcStart = &yItems.Array[startIndex])
								{
									SByte* xSrc = xSrcStart;
									Single* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<SByte> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<SByte> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<SByte> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<SByte> xDoubleColumn, IList<Single> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (SByte* xSrcStart = &itemsX[startIndex])
						fixed (Single* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							SByte* xSrc = xSrcStart;
							Single* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(SByte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.SByte, TY=System.Int32
		private class SByteInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<SByte> xColumn = xValues as IList<SByte>;
				IList<Int32> yColumn = yValues as IList<Int32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<SByte> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int32>();

					Int32 min = yMath.MaxValue;
					Int32 max = yMath.MinValue;
					Int32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<SByte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (SByte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int32* ySrcStart = &yItems.Array[startIndex])
								{
									SByte* xSrc = xSrcStart;
									Int32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<SByte> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<SByte> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<SByte> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<SByte> xDoubleColumn, IList<Int32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (SByte* xSrcStart = &itemsX[startIndex])
						fixed (Int32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							SByte* xSrc = xSrcStart;
							Int32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(SByte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.SByte, TY=System.UInt32
		private class SByteUInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<SByte> xColumn = xValues as IList<SByte>;
				IList<UInt32> yColumn = yValues as IList<UInt32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<SByte> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt32>();

					UInt32 min = yMath.MaxValue;
					UInt32 max = yMath.MinValue;
					UInt32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<SByte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (SByte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt32* ySrcStart = &yItems.Array[startIndex])
								{
									SByte* xSrc = xSrcStart;
									UInt32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<SByte> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<SByte> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<SByte> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<SByte> xDoubleColumn, IList<UInt32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (SByte* xSrcStart = &itemsX[startIndex])
						fixed (UInt32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							SByte* xSrc = xSrcStart;
							UInt32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(SByte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.SByte, TY=System.Int64
		private class SByteInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<SByte> xColumn = xValues as IList<SByte>;
				IList<Int64> yColumn = yValues as IList<Int64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<SByte> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int64>();

					Int64 min = yMath.MaxValue;
					Int64 max = yMath.MinValue;
					Int64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<SByte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (SByte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int64* ySrcStart = &yItems.Array[startIndex])
								{
									SByte* xSrc = xSrcStart;
									Int64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<SByte> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<SByte> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<SByte> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<SByte> xDoubleColumn, IList<Int64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (SByte* xSrcStart = &itemsX[startIndex])
						fixed (Int64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							SByte* xSrc = xSrcStart;
							Int64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(SByte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.SByte, TY=System.UInt64
		private class SByteUInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<SByte> xColumn = xValues as IList<SByte>;
				IList<UInt64> yColumn = yValues as IList<UInt64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<SByte> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt64>();

					UInt64 min = yMath.MaxValue;
					UInt64 max = yMath.MinValue;
					UInt64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<SByte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (SByte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt64* ySrcStart = &yItems.Array[startIndex])
								{
									SByte* xSrc = xSrcStart;
									UInt64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<SByte> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<SByte> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<SByte> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<SByte> xDoubleColumn, IList<UInt64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (SByte* xSrcStart = &itemsX[startIndex])
						fixed (UInt64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							SByte* xSrc = xSrcStart;
							UInt64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(SByte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.SByte, TY=System.Int16
		private class SByteInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<SByte> xColumn = xValues as IList<SByte>;
				IList<Int16> yColumn = yValues as IList<Int16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<SByte> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int16>();

					Int16 min = yMath.MaxValue;
					Int16 max = yMath.MinValue;
					Int16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<SByte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (SByte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int16* ySrcStart = &yItems.Array[startIndex])
								{
									SByte* xSrc = xSrcStart;
									Int16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<SByte> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<SByte> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<SByte> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<SByte> xDoubleColumn, IList<Int16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (SByte* xSrcStart = &itemsX[startIndex])
						fixed (Int16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							SByte* xSrc = xSrcStart;
							Int16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(SByte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.SByte, TY=System.UInt16
		private class SByteUInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<SByte> xColumn = xValues as IList<SByte>;
				IList<UInt16> yColumn = yValues as IList<UInt16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<SByte> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt16>();

					UInt16 min = yMath.MaxValue;
					UInt16 max = yMath.MinValue;
					UInt16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<SByte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (SByte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt16* ySrcStart = &yItems.Array[startIndex])
								{
									SByte* xSrc = xSrcStart;
									UInt16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<SByte> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<SByte> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<SByte> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<SByte> xDoubleColumn, IList<UInt16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (SByte* xSrcStart = &itemsX[startIndex])
						fixed (UInt16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							SByte* xSrc = xSrcStart;
							UInt16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(SByte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.SByte, TY=System.Byte
		private class SByteByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<SByte> xColumn = xValues as IList<SByte>;
				IList<Byte> yColumn = yValues as IList<Byte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<SByte> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Byte>();

					Byte min = yMath.MaxValue;
					Byte max = yMath.MinValue;
					Byte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<SByte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Byte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (SByte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Byte* ySrcStart = &yItems.Array[startIndex])
								{
									SByte* xSrc = xSrcStart;
									Byte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<SByte> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<SByte> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<SByte> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<SByte> xDoubleColumn, IList<Byte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (SByte* xSrcStart = &itemsX[startIndex])
						fixed (Byte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							SByte* xSrc = xSrcStart;
							Byte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(SByte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.SByte, TY=System.SByte
		private class SByteSByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<SByte> xColumn = xValues as IList<SByte>;
				IList<SByte> yColumn = yValues as IList<SByte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<SByte> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<SByte>();

					SByte min = yMath.MaxValue;
					SByte max = yMath.MinValue;
					SByte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<SByte> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<SByte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (SByte* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (SByte* ySrcStart = &yItems.Array[startIndex])
								{
									SByte* xSrc = xSrcStart;
									SByte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<SByte> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<SByte> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<SByte> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<SByte> xDoubleColumn, IList<SByte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (SByte* xSrcStart = &itemsX[startIndex])
						fixed (SByte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							SByte* xSrc = xSrcStart;
							SByte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(SByte xValue)
			{
					return (double)xValue;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.DateTime, TY=System.Double
		private class DateTimeDoubleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<DateTime> xColumn = xValues as IList<DateTime>;
				IList<Double> yColumn = yValues as IList<Double>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<DateTime> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Double>();

					Double min = yMath.MaxValue;
					Double max = yMath.MinValue;
					Double current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<DateTime> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Double> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (DateTime* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Double* ySrcStart = &yItems.Array[startIndex])
								{
									DateTime* xSrc = xSrcStart;
									Double* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<DateTime> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<DateTime> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<DateTime> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<DateTime> xDoubleColumn, IList<Double> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (DateTime* xSrcStart = &itemsX[startIndex])
						fixed (Double* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							DateTime* xSrc = xSrcStart;
							Double* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(DateTime xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.DateTime, TY=System.Single
		private class DateTimeSingleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<DateTime> xColumn = xValues as IList<DateTime>;
				IList<Single> yColumn = yValues as IList<Single>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<DateTime> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Single>();

					Single min = yMath.MaxValue;
					Single max = yMath.MinValue;
					Single current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<DateTime> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Single> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (DateTime* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Single* ySrcStart = &yItems.Array[startIndex])
								{
									DateTime* xSrc = xSrcStart;
									Single* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<DateTime> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<DateTime> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<DateTime> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<DateTime> xDoubleColumn, IList<Single> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (DateTime* xSrcStart = &itemsX[startIndex])
						fixed (Single* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							DateTime* xSrc = xSrcStart;
							Single* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(DateTime xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.DateTime, TY=System.Int32
		private class DateTimeInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<DateTime> xColumn = xValues as IList<DateTime>;
				IList<Int32> yColumn = yValues as IList<Int32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<DateTime> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int32>();

					Int32 min = yMath.MaxValue;
					Int32 max = yMath.MinValue;
					Int32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<DateTime> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (DateTime* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int32* ySrcStart = &yItems.Array[startIndex])
								{
									DateTime* xSrc = xSrcStart;
									Int32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<DateTime> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<DateTime> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<DateTime> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<DateTime> xDoubleColumn, IList<Int32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (DateTime* xSrcStart = &itemsX[startIndex])
						fixed (Int32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							DateTime* xSrc = xSrcStart;
							Int32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(DateTime xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.DateTime, TY=System.UInt32
		private class DateTimeUInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<DateTime> xColumn = xValues as IList<DateTime>;
				IList<UInt32> yColumn = yValues as IList<UInt32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<DateTime> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt32>();

					UInt32 min = yMath.MaxValue;
					UInt32 max = yMath.MinValue;
					UInt32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<DateTime> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (DateTime* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt32* ySrcStart = &yItems.Array[startIndex])
								{
									DateTime* xSrc = xSrcStart;
									UInt32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<DateTime> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<DateTime> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<DateTime> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<DateTime> xDoubleColumn, IList<UInt32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (DateTime* xSrcStart = &itemsX[startIndex])
						fixed (UInt32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							DateTime* xSrc = xSrcStart;
							UInt32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(DateTime xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.DateTime, TY=System.Int64
		private class DateTimeInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<DateTime> xColumn = xValues as IList<DateTime>;
				IList<Int64> yColumn = yValues as IList<Int64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<DateTime> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int64>();

					Int64 min = yMath.MaxValue;
					Int64 max = yMath.MinValue;
					Int64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<DateTime> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (DateTime* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int64* ySrcStart = &yItems.Array[startIndex])
								{
									DateTime* xSrc = xSrcStart;
									Int64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<DateTime> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<DateTime> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<DateTime> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<DateTime> xDoubleColumn, IList<Int64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (DateTime* xSrcStart = &itemsX[startIndex])
						fixed (Int64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							DateTime* xSrc = xSrcStart;
							Int64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(DateTime xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.DateTime, TY=System.UInt64
		private class DateTimeUInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<DateTime> xColumn = xValues as IList<DateTime>;
				IList<UInt64> yColumn = yValues as IList<UInt64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<DateTime> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt64>();

					UInt64 min = yMath.MaxValue;
					UInt64 max = yMath.MinValue;
					UInt64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<DateTime> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (DateTime* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt64* ySrcStart = &yItems.Array[startIndex])
								{
									DateTime* xSrc = xSrcStart;
									UInt64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<DateTime> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<DateTime> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<DateTime> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<DateTime> xDoubleColumn, IList<UInt64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (DateTime* xSrcStart = &itemsX[startIndex])
						fixed (UInt64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							DateTime* xSrc = xSrcStart;
							UInt64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(DateTime xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.DateTime, TY=System.Int16
		private class DateTimeInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<DateTime> xColumn = xValues as IList<DateTime>;
				IList<Int16> yColumn = yValues as IList<Int16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<DateTime> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int16>();

					Int16 min = yMath.MaxValue;
					Int16 max = yMath.MinValue;
					Int16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<DateTime> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (DateTime* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int16* ySrcStart = &yItems.Array[startIndex])
								{
									DateTime* xSrc = xSrcStart;
									Int16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<DateTime> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<DateTime> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<DateTime> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<DateTime> xDoubleColumn, IList<Int16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (DateTime* xSrcStart = &itemsX[startIndex])
						fixed (Int16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							DateTime* xSrc = xSrcStart;
							Int16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(DateTime xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.DateTime, TY=System.UInt16
		private class DateTimeUInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<DateTime> xColumn = xValues as IList<DateTime>;
				IList<UInt16> yColumn = yValues as IList<UInt16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<DateTime> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt16>();

					UInt16 min = yMath.MaxValue;
					UInt16 max = yMath.MinValue;
					UInt16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<DateTime> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (DateTime* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt16* ySrcStart = &yItems.Array[startIndex])
								{
									DateTime* xSrc = xSrcStart;
									UInt16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<DateTime> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<DateTime> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<DateTime> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<DateTime> xDoubleColumn, IList<UInt16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (DateTime* xSrcStart = &itemsX[startIndex])
						fixed (UInt16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							DateTime* xSrc = xSrcStart;
							UInt16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(DateTime xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.DateTime, TY=System.Byte
		private class DateTimeByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<DateTime> xColumn = xValues as IList<DateTime>;
				IList<Byte> yColumn = yValues as IList<Byte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<DateTime> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Byte>();

					Byte min = yMath.MaxValue;
					Byte max = yMath.MinValue;
					Byte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<DateTime> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Byte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (DateTime* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Byte* ySrcStart = &yItems.Array[startIndex])
								{
									DateTime* xSrc = xSrcStart;
									Byte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<DateTime> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<DateTime> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<DateTime> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<DateTime> xDoubleColumn, IList<Byte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (DateTime* xSrcStart = &itemsX[startIndex])
						fixed (Byte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							DateTime* xSrc = xSrcStart;
							Byte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(DateTime xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.DateTime, TY=System.SByte
		private class DateTimeSByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<DateTime> xColumn = xValues as IList<DateTime>;
				IList<SByte> yColumn = yValues as IList<SByte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<DateTime> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<SByte>();

					SByte min = yMath.MaxValue;
					SByte max = yMath.MinValue;
					SByte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<DateTime> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<SByte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (DateTime* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (SByte* ySrcStart = &yItems.Array[startIndex])
								{
									DateTime* xSrc = xSrcStart;
									SByte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<DateTime> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<DateTime> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<DateTime> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<DateTime> xDoubleColumn, IList<SByte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (DateTime* xSrcStart = &itemsX[startIndex])
						fixed (SByte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							DateTime* xSrc = xSrcStart;
							SByte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(DateTime xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.TimeSpan, TY=System.Double
		private class TimeSpanDoubleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<TimeSpan> xColumn = xValues as IList<TimeSpan>;
				IList<Double> yColumn = yValues as IList<Double>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<TimeSpan> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Double>();

					Double min = yMath.MaxValue;
					Double max = yMath.MinValue;
					Double current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<TimeSpan> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Double> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (TimeSpan* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Double* ySrcStart = &yItems.Array[startIndex])
								{
									TimeSpan* xSrc = xSrcStart;
									Double* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<TimeSpan> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<TimeSpan> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<TimeSpan> xColumn, IList<Double> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<TimeSpan> xDoubleColumn, IList<Double> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (TimeSpan* xSrcStart = &itemsX[startIndex])
						fixed (Double* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							TimeSpan* xSrc = xSrcStart;
							Double* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(TimeSpan xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.TimeSpan, TY=System.Single
		private class TimeSpanSingleResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<TimeSpan> xColumn = xValues as IList<TimeSpan>;
				IList<Single> yColumn = yValues as IList<Single>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<TimeSpan> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Single>();

					Single min = yMath.MaxValue;
					Single max = yMath.MinValue;
					Single current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<TimeSpan> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Single> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (TimeSpan* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Single* ySrcStart = &yItems.Array[startIndex])
								{
									TimeSpan* xSrc = xSrcStart;
									Single* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<TimeSpan> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<TimeSpan> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<TimeSpan> xColumn, IList<Single> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<TimeSpan> xDoubleColumn, IList<Single> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (TimeSpan* xSrcStart = &itemsX[startIndex])
						fixed (Single* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							TimeSpan* xSrc = xSrcStart;
							Single* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(TimeSpan xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.TimeSpan, TY=System.Int32
		private class TimeSpanInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<TimeSpan> xColumn = xValues as IList<TimeSpan>;
				IList<Int32> yColumn = yValues as IList<Int32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<TimeSpan> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int32>();

					Int32 min = yMath.MaxValue;
					Int32 max = yMath.MinValue;
					Int32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<TimeSpan> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (TimeSpan* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int32* ySrcStart = &yItems.Array[startIndex])
								{
									TimeSpan* xSrc = xSrcStart;
									Int32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<TimeSpan> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<TimeSpan> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<TimeSpan> xColumn, IList<Int32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<TimeSpan> xDoubleColumn, IList<Int32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (TimeSpan* xSrcStart = &itemsX[startIndex])
						fixed (Int32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							TimeSpan* xSrc = xSrcStart;
							Int32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(TimeSpan xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.TimeSpan, TY=System.UInt32
		private class TimeSpanUInt32Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<TimeSpan> xColumn = xValues as IList<TimeSpan>;
				IList<UInt32> yColumn = yValues as IList<UInt32>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<TimeSpan> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt32>();

					UInt32 min = yMath.MaxValue;
					UInt32 max = yMath.MinValue;
					UInt32 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<TimeSpan> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt32> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (TimeSpan* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt32* ySrcStart = &yItems.Array[startIndex])
								{
									TimeSpan* xSrc = xSrcStart;
									UInt32* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<TimeSpan> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<TimeSpan> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<TimeSpan> xColumn, IList<UInt32> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<TimeSpan> xDoubleColumn, IList<UInt32> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (TimeSpan* xSrcStart = &itemsX[startIndex])
						fixed (UInt32* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							TimeSpan* xSrc = xSrcStart;
							UInt32* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(TimeSpan xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.TimeSpan, TY=System.Int64
		private class TimeSpanInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<TimeSpan> xColumn = xValues as IList<TimeSpan>;
				IList<Int64> yColumn = yValues as IList<Int64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<TimeSpan> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int64>();

					Int64 min = yMath.MaxValue;
					Int64 max = yMath.MinValue;
					Int64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<TimeSpan> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (TimeSpan* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int64* ySrcStart = &yItems.Array[startIndex])
								{
									TimeSpan* xSrc = xSrcStart;
									Int64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<TimeSpan> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<TimeSpan> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<TimeSpan> xColumn, IList<Int64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<TimeSpan> xDoubleColumn, IList<Int64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (TimeSpan* xSrcStart = &itemsX[startIndex])
						fixed (Int64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							TimeSpan* xSrc = xSrcStart;
							Int64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(TimeSpan xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.TimeSpan, TY=System.UInt64
		private class TimeSpanUInt64Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<TimeSpan> xColumn = xValues as IList<TimeSpan>;
				IList<UInt64> yColumn = yValues as IList<UInt64>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<TimeSpan> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt64>();

					UInt64 min = yMath.MaxValue;
					UInt64 max = yMath.MinValue;
					UInt64 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<TimeSpan> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt64> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (TimeSpan* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt64* ySrcStart = &yItems.Array[startIndex])
								{
									TimeSpan* xSrc = xSrcStart;
									UInt64* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<TimeSpan> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<TimeSpan> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<TimeSpan> xColumn, IList<UInt64> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<TimeSpan> xDoubleColumn, IList<UInt64> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (TimeSpan* xSrcStart = &itemsX[startIndex])
						fixed (UInt64* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							TimeSpan* xSrc = xSrcStart;
							UInt64* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(TimeSpan xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.TimeSpan, TY=System.Int16
		private class TimeSpanInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<TimeSpan> xColumn = xValues as IList<TimeSpan>;
				IList<Int16> yColumn = yValues as IList<Int16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<TimeSpan> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Int16>();

					Int16 min = yMath.MaxValue;
					Int16 max = yMath.MinValue;
					Int16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<TimeSpan> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Int16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (TimeSpan* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Int16* ySrcStart = &yItems.Array[startIndex])
								{
									TimeSpan* xSrc = xSrcStart;
									Int16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<TimeSpan> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<TimeSpan> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<TimeSpan> xColumn, IList<Int16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<TimeSpan> xDoubleColumn, IList<Int16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (TimeSpan* xSrcStart = &itemsX[startIndex])
						fixed (Int16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							TimeSpan* xSrc = xSrcStart;
							Int16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(TimeSpan xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.TimeSpan, TY=System.UInt16
		private class TimeSpanUInt16Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<TimeSpan> xColumn = xValues as IList<TimeSpan>;
				IList<UInt16> yColumn = yValues as IList<UInt16>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<TimeSpan> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<UInt16>();

					UInt16 min = yMath.MaxValue;
					UInt16 max = yMath.MinValue;
					UInt16 current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<TimeSpan> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<UInt16> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (TimeSpan* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (UInt16* ySrcStart = &yItems.Array[startIndex])
								{
									TimeSpan* xSrc = xSrcStart;
									UInt16* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<TimeSpan> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<TimeSpan> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<TimeSpan> xColumn, IList<UInt16> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<TimeSpan> xDoubleColumn, IList<UInt16> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (TimeSpan* xSrcStart = &itemsX[startIndex])
						fixed (UInt16* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							TimeSpan* xSrc = xSrcStart;
							UInt16* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(TimeSpan xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.TimeSpan, TY=System.Byte
		private class TimeSpanByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<TimeSpan> xColumn = xValues as IList<TimeSpan>;
				IList<Byte> yColumn = yValues as IList<Byte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<TimeSpan> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<Byte>();

					Byte min = yMath.MaxValue;
					Byte max = yMath.MinValue;
					Byte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<TimeSpan> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<Byte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (TimeSpan* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (Byte* ySrcStart = &yItems.Array[startIndex])
								{
									TimeSpan* xSrc = xSrcStart;
									Byte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<TimeSpan> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<TimeSpan> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<TimeSpan> xColumn, IList<Byte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<TimeSpan> xDoubleColumn, IList<Byte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (TimeSpan* xSrcStart = &itemsX[startIndex])
						fixed (Byte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							TimeSpan* xSrc = xSrcStart;
							Byte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(TimeSpan xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion

		#region Autogenerated Resampler for TX=System.TimeSpan, TY=System.SByte
		private class TimeSpanSByteResampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<TimeSpan> xColumn = xValues as IList<TimeSpan>;
				IList<SByte> yColumn = yValues as IList<SByte>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<TimeSpan> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<SByte>();

					SByte min = yMath.MaxValue;
					SByte max = yMath.MinValue;
					SByte current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<TimeSpan> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<SByte> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (TimeSpan* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (SByte* ySrcStart = &yItems.Array[startIndex])
								{
									TimeSpan* xSrc = xSrcStart;
									SByte* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<TimeSpan> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<TimeSpan> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<TimeSpan> xColumn, IList<SByte> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<TimeSpan> xDoubleColumn, IList<SByte> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (TimeSpan* xSrcStart = &itemsX[startIndex])
						fixed (SByte* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							TimeSpan* xSrc = xSrcStart;
							SByte* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(TimeSpan xValue)
			{
					return xValue.Ticks;
				}
		}
		#endregion
	}
}
// ReSharper Restore All