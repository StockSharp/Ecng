<#@ template language="C#" #>
<# 
var xTypes = new System.Collections.Generic.List<string> {"Double", "Single", "Int32", "UInt32", "Int64", "UInt64", "Int16", "UInt16", "Byte", "SByte", "DateTime", "TimeSpan"};
var yTypes = new System.Collections.Generic.List<string> {"Double", "Single", "Int32", "UInt32", "Int64", "UInt64", "Int16", "UInt16", "Byte", "SByte"};
 #>
// *************************************************************************************
// ULTRACHART™ © Copyright ulc software Services Ltd. 2011-2014. All rights reserved.
//  
// Web: http://www.ultrachart.com
// Support: support@ultrachart.com
// 
// Resamplers.cs is part of Ultrachart, a High Performance WPF & Silverlight Chart. 
// For full terms and conditions of the license, see http://www.ultrachart.com/ultrachart-eula/
// 
// This source code is protected by international copyright law. Unauthorized
// reproduction, reverse-engineering, or distribution of all or any portion of
// this source code is strictly prohibited.
// 
// This source code contains confidential and proprietary trade secrets of
// ulc software Services Ltd., and should at no time be copied, transferred, sold,
// distributed or made available without express written permission.
// *************************************************************************************
using System;
using System.Collections;
using System.Collections.Generic;
using Ecng.Xaml.Charting.Common.Extensions;
using Ecng.Xaml.Charting.Model.DataSeries;
using Ecng.Xaml.Charting.Numerics.GenericMath;
// ReSharper Disable All

// <autogenerated>
// This code is autogenerated by Resamplers.tt. Do not modify this code
// </autogenerated>
namespace Ecng.Xaml.Charting.Numerics.PointResamplers
{	
	/// <summary>
    /// Instantiates <see cref="IPointResampler"/> instances
    /// </summary>
    public class PointResamplerFactory : IPointResamplerFactory
    {
		private static readonly Dictionary<Type, Dictionary<Type, IPointResampler>> _resamplers = new Dictionary<Type, Dictionary<Type, IPointResampler>>();
		static PointResamplerFactory()
		{
			Dictionary<Type, IPointResampler> yDict = null;
<# 
foreach (string xType in xTypes)
{ 	
#>	
			yDict = new Dictionary<Type, IPointResampler>();
			_resamplers.Add(typeof(<#= xType #>), yDict);
<# 
foreach (string yType in yTypes)
{	
#>
			yDict.Add(typeof(<#= yType #>), new <#= xType #><#= yType #>Resampler());
<# 
}
#>
<# 
}
#>
		}

        /// <summary>
        /// Instantiates a <see cref="IPointResampler"/> instance for the combination of <typeparamref name="TX"/> and <typeparamref name="TY"/>
        /// </summary>
        public IPointResampler GetPointResampler<TX, TY>() where TX : IComparable where TY : IComparable
        {
            var yType = typeof(TY);
            var xType = typeof(TX);

			try
			{
				return _resamplers[xType][yType];
			}
			catch(Exception caught)
			{
				throw new InvalidOperationException(string.Format("No resampler exists for the combination of TX={0} and TY={1}. Please contact support", xType, yType));
			}
        }

	<# 
	foreach (string xType in xTypes)
	{ 
	foreach (string yType in yTypes)
	{	
	#>

		#region Autogenerated Resampler for TX=System.<#= xType #>, TY=System.<#= yType #>
		private class <#= xType #><#= yType #>Resampler : PointResamplerBase
		{		
			public sealed override IPointSeries Execute(ResamplingMode resamplingMode, IndexRange pointRange, int viewportWidth, bool isFifo, bool isCategoryAxis, IList xValues, IList yValues, bool? dataIsSorted, bool? dataIsEvenlySpaced, bool? dataIsDisplayedAs2d, IRange visibleXRange)
			{
				IList<<#= xType #>> xColumn = xValues as IList<<#= xType #>>;
				IList<<#= yType #>> yColumn = yValues as IList<<#= yType #>>;

				if (!RequiresReduction(resamplingMode, pointRange, viewportWidth))
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Cluster2D)
					return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.MinMaxWithUnevenSpacing)
					return ReducePointsMinMaxUnevenlySpaced(xColumn, (IList<double>)yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
				if (resamplingMode == ResamplingMode.MinMax || resamplingMode == ResamplingMode.Nyquist)
					return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Max)
					return ReducePointsMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Min)
					return ReducePointsMin(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Mid)
					return ReducePointsMid(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
				if (resamplingMode == ResamplingMode.Auto)
				{
					if (dataIsDisplayedAs2d == true)
						return ResampleInClusterMode(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					if (dataIsEvenlySpaced == true || isCategoryAxis)
					{
						return ReducePointsMinMax(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis);
					}
					if (dataIsSorted == true)
					{
						return ReducePointsMinMaxUnevenlySpaced(xColumn, yColumn, pointRange, viewportWidth, isCategoryAxis, visibleXRange);
					}
					// no resampling - unsorted data
					return ResampleWithoutReduction(xColumn, yColumn, pointRange, false);
				}

				throw new Exception(string.Format("Resampling Mode {0} has not been handled", resamplingMode));   
			}

			private IPointSeries ReducePointsMinMax(IList<<#= xType #>> xColumn, IList<<#= yType #>> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = 2*setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					var yMath = GenericMathFactory.New<<#= yType #>>();

					<#= yType #> min = yMath.MaxValue;
					<#= yType #> max = yMath.MinValue;
					<#= yType #> current;
					int i = startIndex, counter = bucketSize;
					int stopIndex = endIndex - setLength%bucketSize;

					UncheckedList<<#= xType #>> xItems = !isCategoryAxis ? xColumn.ToUncheckedList(false) : null;
					UncheckedList<<#= yType #>> yItems = yColumn.ToUncheckedList(true);

					var xValues = reducedPoints.XValues;
					var yValues = reducedPoints.YValues;

					stopIndex = Math.Min(yItems.Count, stopIndex);

	#if !SILVERLIGHT
					if (xItems != null)
					{
						unsafe
						{
							fixed (<#= xType #>* xSrcStart = &xItems.Array[startIndex])
							{
								fixed (<#= yType #>* ySrcStart = &yItems.Array[startIndex])
								{
									<#= xType #>* xSrc = xSrcStart;
									<#= yType #>* ySrc = ySrcStart;

									for (; i <= stopIndex; ++i, ++xSrc, ++ySrc)
									{
										current = *ySrc;
										if (!(min < current)) min = current;
										if (!(max > current)) max = current;

										if (--counter == 0)
										{
											double x = TxToDouble(*xSrc);

											xValues.Add(x);
											xValues.Add(x);
											yValues.Add((double)min);
											yValues.Add((double)max);

											min = yMath.MaxValue;
											max = yMath.MinValue;

											counter = bucketSize;
										}
									}

								}
							}
						}
					}
					else
	#endif
					{
						for (; i <= stopIndex; i++)
						{
							current = yItems[i];

							if (!(min < current)) min = current;
							if (!(max > current)) max = current;

							if (--counter == 0)
							{
								double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);

								xValues.Add(x);
								xValues.Add(x);
								yValues.Add((double)min);
								yValues.Add((double)max);

								min = yMath.MaxValue;
								max = yMath.MinValue;

								counter = bucketSize;
							}
						}
					}

					if (endIndex != stopIndex)
					{
						for (; i <= endIndex; i++)
						{
							current = yItems[i];
							if (!(min < current)) min = current;
							if (!(max > current)) max = current;
						}

						double x = isCategoryAxis ? i : (xItems != null ? TxToDouble(xItems[xItems.Count-1]) : TxToDouble(xColumn[xColumn.Count-1]));

						xValues.Add(x);
						xValues.Add(x);
						yValues.Add((double)min);
						yValues.Add((double)max); 
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMax(IList<<#= xType #>> xColumn, IList<<#= yType #>> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, max));

							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMin(IList<<#= xType #>> xColumn, IList<<#= yType #>> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2*viewportWidth;
					int bucketSize = setLength/minResampledLength;
					int actualResampledLength = setLength/bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, min));

							min = double.MaxValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ReducePointsMid(IList<<#= xType #>> xColumn, IList<<#= yType #>> yColumn, IndexRange pointRange, int viewportWidth, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;
					int minResampledLength = 2 * viewportWidth;
					int bucketSize = setLength / minResampledLength;
					int actualResampledLength = setLength / bucketSize;

					var reducedPoints = new Point2DSeries(actualResampledLength);

					double min = double.MaxValue;
					double max = double.MinValue;

					var items = yColumn.ToUncheckedList();
					for (int i = startIndex, counter = 0; i <= endIndex; i++)
					{
						double current = (double)items[i];
						min = min < current ? min : current;
						max = max > current ? max : current;

						if (++counter >= bucketSize)
						{
							double x = isCategoryAxis ? i : TxToDouble(xColumn[i]);
							reducedPoints.Add(new Point2D(x, 0.5 * (max + min)));

							min = double.MaxValue;
							max = double.MinValue;
							counter = 0;
						}
					}

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private IPointSeries ResampleWithoutReduction(IList<<#= xType #>> xDoubleColumn, IList<<#= yType #>> yColumn, IndexRange pointRange, bool isCategoryAxis)
			{
				unchecked
				{
					int endIndex = pointRange.Max;
					int startIndex = pointRange.Min;
					int setLength = endIndex - startIndex + 1;

					double max = double.MinValue;

					var itemsX = xDoubleColumn.ToUncheckedList();
					var itemsY = yColumn.ToUncheckedList();

					var reducedPoints = new Point2DSeries(setLength);
                
					var xValues = reducedPoints.XValues.ToUncheckedList();
					var yValues = reducedPoints.YValues.ToUncheckedList();

					reducedPoints.XValues.SetCount(setLength);
					reducedPoints.YValues.SetCount(setLength);

                

	#if SILVERLIGHT
					// For Silverlight, simple memcpy plus cast to double (if applicable)
					for (int i = startIndex, j = 0; i <= endIndex; i++, j++)
					{
						xValues[j] = isCategoryAxis ? i : TxToDouble(itemsX[i]);
						yValues[j] = itemsY[i];
					}
	#else
					unsafe
					{
						fixed (<#= xType #>* xSrcStart = &itemsX[startIndex])
						fixed (<#= yType #>* ySrcStart = &itemsY[startIndex])
						fixed (double* xDestStart = &xValues[0])
						fixed (double* yDestStart = &yValues[0])
						{
							<#= xType #>* xSrc = xSrcStart;
							<#= yType #>* ySrc = ySrcStart;
							double* xDest = xDestStart;
							double* yDest = yDestStart;

							int i = startIndex, j = 0;

							if (setLength > 16)
							{
								// Unroll loop in blocks of 16 
								int endIndex2 = endIndex - ((endIndex - startIndex) % 16);
								for (; i != endIndex2; )
								{
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
									*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
								}
							}

							// Complete loop
							for (; i <= endIndex; )
							{
								*xDest = isCategoryAxis ? i : TxToDouble(*xSrc); *yDest = *ySrc; ++xDest; ++xSrc; ++yDest; ++ySrc; ++i;
							}
						}
					}
	#endif

					reducedPoints.Freeze();
					return reducedPoints;
				}
			}

			private static double TxToDouble(<#= xType #> xValue)
			{
	<#
	if(xType == "DateTime" || xType == "TimeSpan")
	{#>
				return xValue.Ticks;
	<#
	}
	else
	{
	#>
				return (double)xValue;
	<#
	}
	#>
			}
		}
		#endregion
<# 
} 
}
#>
	}
}
// ReSharper Restore All