<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="SqlServerReservedWords" xml:space="preserve">
    <value>add
except
percent
all
exec
plan
alter
execute
precision
and
exists
primary
any
exit
print
as
fetch
proc
asc
file
procedure
authorization
fillfactor
public
backup
for
raiserror
begin
foreign
read
between
freetext
readtext
break
freetexttable
reconfigure
browse
from
references
bulk
full
replication
by
function
restore
cascade
goto
restrict
case
grant
return
check
group
revoke
checkpoint
having
right
close
holdlock
rollback
clustered
identity
rowcount
coalesce
identity_insert
rowguidcol
collate
identitycol
rule
column
if
save
commit
in
schema
compute
index
select
constraint
inner
session_user
contains
insert
set
containstable
intersect
setuser
continue
into
shutdown
convert
is
some
create
join
statistics
cross
key
system_user
current
kill
table
current_date
left
textsize
current_time
like
then
current_timestamp
lineno
to
current_user
load
top
cursor
national
tran
database
nocheck
transaction
dbcc
nonclustered
trigger
deallocate
not
truncate
declare
null
tsequal
default
nullif
union
delete
of
unique
deny
off
update
desc
offsets
updatetext
disk
on
use
distinct
open
user
distributed
opendatasource
values
double
openquery
varying
drop
openrowset
view
dummy
openxml
waitfor
dump
option
when
else
or
where
end
order
while
errlvl
outer
with
escape
over
writetext
absolute
exec
overlaps
action
execute
pad
ada
exists
partial
add
external
pascal
all
extract
position
allocate
false
precision
alter
fetch
prepare
and
first
preserve
any
float
primary
are
for
prior
as
foreign
privileges
asc
fortran
procedure
assertion
found
public
at
from
read
authorization
full
real
avg
get
references
begin
global
relative
between
go
restrict
bit
goto
revoke
bit_length
grant
right
both
group
rollback
by
having
rows
cascade
hour
schema
cascaded
identity
scroll
case
immediate
second
cast
in
section
catalog
include
select
char
index
session
char_length
indicator
session_user
character
initially
set
character_length
inner
size
check
input
smallint
close
insensitive
some
coalesce
insert
space
collate
int
sql
collation
integer
sqlca
column
intersect
sqlcode
commit
interval
sqlerror
connect
into
sqlstate
connection
is
sqlwarning
constraint
isolation
substring
constraints
join
sum
continue
key
system_user
convert
language
table
corresponding
last
temporary
count
leading
then
create
left
time
cross
level
timestamp
current
like
timezone_hour
current_date
local
timezone_minute
current_time
lower
to
current_timestamp
match
trailing
current_user
max
transaction
cursor
min
translate
date
minute
translation
day
module
trim
deallocate
month
true
dec
names
union
decimal
national
unique
declare
natural
unknown
default
nchar
update
deferrable
next
upper
deferred
no
usage
delete
none
user
desc
not
using
describe
null
value
descriptor
nullif
values
diagnostics
numeric
varchar
disconnect
octet_length
varying
distinct
of
view
domain
on
when
double
only
whenever
drop
open
where
else
option
with
end
or
work
end-exec
order
write
escape
outer
year
except
output
zone
exception
absolute
found
prepare
action
free
preserve
admin
fulltexttable
prior
after
general
privileges
aggregate
get
reads
alias
global
real
allocate
go
recursive
are
grouping
ref
array
host
referencing
assertion
hour
relative
at
ignore
result
before
immediate
returns
binary
indicator
role
bit
initialize
rollup
blob
initially
routine
boolean
inout
row
both
input
rows
breadth
int
savepoint
call
integer
scroll
cascaded
interval
scope
cast
isolation
search
catalog
iterate
second
char
language
section
character
large
sequence
class
last
session
clob
lateral
sets
collation
leading
size
completion
less
smallint
connect
level
space
connection
limit
specific
constraints
local
specifictype
constructor
localtime
sql
corresponding
localtimestamp
sqlexception
cube
locator
sqlstate
current_path
map
sqlwarning
current_role
match
start
cycle
minute
state
data
modifies
statement
date
modify
static
day
module
structure
dec
month
temporary
decimal
names
terminate
deferrable
natural
than
deferred
nchar
time
depth
nclob
timestamp
deref
new
timezone_hour
describe
next
timezone_minute
descriptor
no
trailing
destroy
none
translation
destructor
numeric
treat
deterministic
object
true
dictionary
old
under
diagnostics
only
unknown
disconnect
operation
unnest
domain
ordinality
usage
dynamic
out
using
each
output
value
end-exec
pad
varchar
equals
parameter
variable
every
parameters
whenever
exception
partial
without
external
path
work
false
postfix
write
first
prefix
year
float
preorder
zone</value>
  </data>
</root>